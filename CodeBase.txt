Ingestion Results for d:\SIDE_GIG\SadhnaFlow
Summary
Directory: SadhnaFlow
Files analyzed: 30

Estimated tokens: 53.1k


Directory structure:
└── SadhnaFlow/
    ├── README.md
    ├── app.json
    ├── eas.json
    ├── eslint.config.js
    ├── LICENSE
    ├── package.json
    ├── reciation_log.json
    ├── tsconfig.json
    ├── app/
    │   ├── +not-found.tsx
    │   ├── (tabs)/
    │   │   ├── goals.tsx
    │   │   ├── index.tsx
    │   │   ├── insights.tsx
    │   │   ├── japa.tsx
    │   │   ├── journal.tsx
    │   │   ├── library.tsx
    │   │   └── vigraha.tsx
    │   └── stotra/
    │       └── [id].tsx
    ├── assets/
    │   ├── audio/
    │   ├── fonts/
    │   │   └── SpaceMono-Regular.ttf
    │   ├── images/
    │   ├── screenshots/
    │   └── video/
    ├── components/
    │   ├── AddGoalModal.tsx
    │   ├── AudioPlayer.tsx
    │   ├── CustomSlider.tsx
    │   ├── JapaCounter.tsx
    │   ├── MonthYearPickerModal.tsx
    │   └── RecitationLogger.tsx
    ├── constants/
    ├── data/
    │   └── stotras.ts
    ├── hooks/
    │   └── useAudioPlayer.ts
    ├── scripts/
    │   └── reset-project.js
    ├── services/
    │   └── StorageService.ts
    └── .expo/
        ├── README.md
        ├── devices.json
        └── types/


File Contents

===============================================
File: README.md
===============================================

# 🕉️ SadhnaFlow - Digital Sadhana Companion

<div align="center">
  <img src="./assets/images/icon.png" alt="SadhnaFlow Logo" width="120" height="120">
  
  **॥ ॐ भैरवाय नमः ॥**
  
  *"धर्मे च अर्थे च कामे च मोक्षे च भरतर्षभ।  
  यदिहास्ति तदन्यत्र यन्नेहास्ति न तत्क्वचित्॥"*
  
  *"Whatever exists here, exists elsewhere too. What does not exist here, does not exist anywhere."*
</div>

---
<div align="center">
  🙏 श्री कालभैरव स्तुति

<https://github.com/user-attachments/assets/60196a6d-5c81-4384-8972-12ab1d350b47>

*॥ॐ क्रों कालभैरवाय नमः॥*

*काल भैरव काल भैरव काल भैरव पाहि माम्।  
त्राहि माम् शरणागत देहि मे शरणम् सदा॥*

*Kaal Bhairav Kaal Bhairav Kaal Bhairav Paahi Maam  
Traahi Maam Sharanagata Dehi Me Sharanam Sadaa*
</div>

## 📱 Demo Video

<div align="center">

<https://github.com/user-attachments/assets/6474d1b2-1ca8-49eb-9778-651d5dd0ac64>

*Experience the divine journey through SadhnaFlow*

**📱 See in Action:** Japa Counter • Sacred Audio • Goal Tracking • Spiritual Journal

</div>

## ✨ About SadhnaFlow

SadhnaFlow is a sacred digital companion designed to enhance your spiritual journey through traditional Hindu practices. Dedicated to **श्री कालभैरव** (Shri Kaal Bhairav), this app brings ancient wisdom into the modern era, helping devotees maintain consistent sadhana (spiritual practice) with devotion and discipline.

### 🌟 Spiritual Significance

*"साधना वे करता है जो स्वयं को जानना चाहता है"*  
*"Sadhana is done by one who wishes to know oneself"*

In the tradition of Sanatan Dharma, regular spiritual practice is the pathway to self-realization. SadhnaFlow honors this sacred tradition by providing:

- **Digital Japa Mala** for mantra chanting
- **Sacred Audio Library** with authentic recitations
- **Spiritual Goal Tracking** for consistent practice
- **Personal Journal** for spiritual insights
- **Progress Analytics** to track your spiritual growth

---

## 📱 Features

### 🔢 Japa Counter

- Digital mala for accurate count tracking
- Multiple mantras and prayers support
- Session history and statistics
- Audio accompaniment with sacred chants

### 🎵 Audio Library

- **Bhairav Ashtottara** - 108 names of Lord Bhairav
- **Bhairav Tandav** - Divine cosmic dance
- **Bhairava Stotra** - Sacred hymns
- **Kaal Bhairav** - Powerful mantras
- **Hanuman Chalisa** - Complete recitation

### 🎯 Spiritual Goals

- Set daily/weekly spiritual targets
- Track mantra counts and meditation time
- Progress visualization
- Achievement milestones

### 📖 Sacred Library

- Collection of stotras and prayers
- Synchronized audio-text experience
- Sanskrit with transliteration
- Meaning and significance explanations

### 🕉️Vigraha (Divine Form)

- Sacred images of Lord Bhairav for meditation
- Multiple divine forms for visual contemplation
- Sadhana instructions for spiritual practice
- Interactive gallery with detailed descriptions

### 📊Insights & Analytics

- Spiritual practice trends
- Consistency tracking
- Personal growth metrics
- Monthly and yearly reports

### ✍️ Spiritual Journal

- Record daily spiritual experiences
- Meditation insights
- Dream journals
- Gratitude entries

---

## 📸 Screenshots

<div align="center">
  <table>
    <tr>
      <td align="center">
        <img src="./assets/screenshots/0.jpeg" width="200" alt="Home Screen">
        <br><em>Sacred Home</em>
      </td>
      <td align="center">
        <img src="./assets/screenshots/1.jpeg" width="200" alt="Japa Counter">
        <br><em>Digital Mala</em>
      </td>
      <td align="center">
        <img src="./assets/screenshots/2.jpeg" width="200" alt="Audio Library">
        <br><em>Sacred Library</em>
      </td>
    </tr>
    <tr>
      <td align="center">
        <img src="./assets/screenshots/3.jpeg" width="200" alt="Goals">
        <br><em>Sacred Text</em>
      </td>
      <td align="center">
        <img src="./assets/screenshots/4.jpeg" width="200" alt="Library">
        <br><em>Log Recitation</em>
      </td>
      <td align="center">
        <img src="./assets/screenshots/5.jpeg" width="200" alt="Insights">
        <br><em>Progress Insights</em>
      </td>
    </tr>
    <tr>
      <td align="center">
        <img src="./assets/screenshots/6.jpeg" width="200" alt="Journal">
        <br><em>Spiritual Goals</em>
      </td>
      <td align="center">
        <img src="./assets/screenshots/7.jpeg" width="200" alt="Settings">
        <br><em>Spiritual Journal</em>
      </td>
      <td align="center">
        <img src="./assets/screenshots/8.jpeg" width="200" alt="Settings">
        <br><em>Divine Vigraha</em>
      </td>
    </tr>
  </table>
</div>

---

## 🛠️ Technology Stack

- **Framework**: React Native with Expo
- **Language**: TypeScript
- **Navigation**: Expo Router
- **Storage**: AsyncStorage
- **Audio**: Expo AV
- **UI**: React Native Components

---

## 🚀 Getting Started

### Prerequisites

- Node.js (v16 or higher)
- npm or yarn
- Expo CLI
- Android Studio / Xcode (for device testing)

### Installation

1. **Clone the sacred repository**

   ```bash
   git clone https://github.com/yourusername/SadhnaFlow.git
   cd SadhnaFlow
   ```

2. **Install dependencies**

   ```bash
   npm install
   # or
   yarn install
   ```

3. **Start the development server**

   ```bash
   npx expo start
   ```

4. **Run on device**
   - Scan QR code with Expo Go app
   - Or run on emulator/simulator

---

## 📂 Project Structure

```
SadhnaFlow/
├── app/                    # Main application screens
│   ├── (tabs)/            # Tab-based navigation
│   │   ├── index.tsx      # Home screen
│   │   ├── japa.tsx       # Japa counter
│   │   ├── goals.tsx      # Spiritual goals
│   │   ├── library.tsx    # Sacred library
│   │   ├── vigraha.tsx    # Divine form gallery
│   │   ├── insights.tsx   # Analytics
│   │   └── journal.tsx    # Spiritual journal
│   └── stotra/            # Individual stotra pages
├── components/            # Reusable components
│   ├── AddGoalModal.tsx   # Goal creation modal
│   ├── AudioPlayer.tsx    # Audio playback component
│   ├── CustomSlider.tsx   # Custom UI slider
│   ├── JapaCounter.tsx    # Digital mala counter
│   └── RecitationLogger.tsx # Log spiritual sessions
├── assets/               # Static assets
│   ├── audio/           # Sacred audio files
│   ├── images/          # Icons and divine images
│   │   ├── Batuka_Bhairav.jpg # Divine form images
│   │   └── Kal_Bhairav.jpg    # Sacred iconography
│   ├── screenshots/     # App screenshots
│   └── video/           # Demo video
├── data/                # Spiritual content data
│   └── stotras.ts       # Sacred text database
├── services/            # Storage and API services
│   └── StorageService.ts # Local data management
└── hooks/               # Custom React hooks
    └── useAudioPlayer.ts # Audio playback hook
```

## 🌸 Why Spiritual Practice Matters

### Mental Peace & Clarity

- **Reduces Stress**: Regular chanting and meditation activate the parasympathetic nervous system
- **Improves Focus**: Mantra repetition enhances concentration and mental clarity
- **Emotional Balance**: Spiritual practices help regulate emotions and reduce anxiety

### Spiritual Growth

- **Self-Awareness**: Regular sadhana leads to deeper self-understanding
- **Divine Connection**: Consistent practice strengthens the bond with the divine
- **Karmic Purification**: Sacred chants help purify negative karmas

### Physical Well-being

- **Better Sleep**: Evening prayers and meditation improve sleep quality
- **Reduced Blood Pressure**: Chanting mantras has proven cardiovascular benefits
- **Enhanced Immunity**: Spiritual practices boost overall health and immunity

---

## 📱 Download & Usage

1. **Install** the app on your Android device
2. **Set Daily Goals** for your spiritual practice
3. **Use Japa Counter** for mantra chanting
4. **Listen to Sacred Audio** during practice
5. **View Divine Forms** in Vigraha for meditation
6. **Track Progress** through insights
7. **Maintain** a spiritual journal

---

## 🤝 Contributing

We welcome contributions to enhance this sacred digital companion. Please:

1. Fork the repository
2. Create a feature branch
3. Make your changes with devotion
4. Submit a pull request

### Guidelines

- Maintain the spiritual essence of the app
- Test all features thoroughly
- Follow TypeScript best practices
- Add appropriate documentation

---

## 📄 License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

---

## 🙏 Acknowledgments

- **श्री कालभैरव** for divine inspiration
- **Sanatan Dharma** tradition for timeless wisdom
- **Audio Contributors** for sacred recordings
- **Beta Testers** for valuable feedback
- **Open Source Community** for tools and libraries

---

<div align="center">
  <img src="./assets/images/icon.png" alt="SadhnaFlow" width="60" height="60">
  
  **॥ हर हर महादेव ॥**  
  **॥ श्री कालभैरवाय नमः ॥**
  
  *May this digital companion guide you on your spiritual journey*  
  *आपकी आध्यात्मिक यात्रा में यह दिव्य साथी आपका मार्गदर्शन करे*
  
  ---
  
  **Made with 🕉️ and ❤️ for the spiritual community**
  
  *Version 1.0.0 | Built with React Native & Expo*
</div>



===============================================
File: app.json
===============================================

{
  "expo": {
    "name": "SadhnaFlow",
    "slug": "SadhnaFlow",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/images/icon.png",
    "scheme": "sadhnaflow",
    "userInterfaceStyle": "automatic",
    "newArchEnabled": true,
    "ios": {
      "supportsTablet": true
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/images/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "edgeToEdgeEnabled": true,
      "permissions": [
        "android.permission.RECORD_AUDIO",
        "android.permission.MODIFY_AUDIO_SETTINGS"
      ],
      "package": "com.himacodes.SadhnaFlow"
    },
    "web": {
      "bundler": "metro",
      "output": "static",
      "favicon": "./assets/images/favicon.png"
    },
    "plugins": [
      "expo-router",
      [
        "expo-splash-screen",
        {
          "image": "./assets/images/splash-icon.png",
          "imageWidth": 200,
          "resizeMode": "contain",
          "backgroundColor": "#ffffff"
        }
      ],
      "expo-audio",
      "expo-asset"
    ],
    "experiments": {
      "typedRoutes": true
    },
    "extra": {
      "router": {},
      "eas": {
        "projectId": "b20656a7-6df7-4220-b76f-97f6f3837d8d"
      }
    }
  }
}


===============================================
File: eas.json
===============================================

{
  "cli": {
    "version": ">= 16.17.3",
    "appVersionSource": "remote"
  },
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal"
    },
    "preview": {
      "distribution": "internal"
    },
    "production": {
      "autoIncrement": true
    }
  },
  "submit": {
    "production": {}
  }
}


===============================================
File: eslint.config.js
===============================================

// https://docs.expo.dev/guides/using-eslint/
const { defineConfig } = require('eslint/config');
const expoConfig = require('eslint-config-expo/flat');

module.exports = defineConfig([
  expoConfig,
  {
    ignores: ['dist/*'],
  },
]);


===============================================
File: LICENSE
===============================================

MIT License

Copyright (c) 2025 Himanshu Mohanty

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


===============================================
File: package.json
===============================================

{
  "name": "sadhnaflow",
  "main": "expo-router/entry",
  "version": "1.0.0",
  "scripts": {
    "start": "expo start",
    "reset-project": "node ./scripts/reset-project.js",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web",
    "lint": "expo lint"
  },
  "dependencies": {
    "@expo/vector-icons": "^14.1.0",
    "@react-native-async-storage/async-storage": "2.1.2",
    "@react-native-community/slider": "^5.0.1",
    "@react-navigation/bottom-tabs": "^7.4.4",
    "@react-navigation/elements": "^2.3.8",
    "@react-navigation/native": "^7.1.16",
    "expo": "~53.0.20",
    "expo-asset": "~11.1.7",
    "expo-audio": "~0.4.8",
    "expo-av": "~15.1.7",
    "expo-blur": "~14.1.5",
    "expo-constants": "~17.1.7",
    "expo-font": "~13.3.2",
    "expo-haptics": "~14.1.4",
    "expo-image": "~2.4.0",
    "expo-linking": "~7.1.7",
    "expo-router": "~5.1.4",
    "expo-splash-screen": "~0.30.10",
    "expo-status-bar": "~2.2.3",
    "expo-symbols": "~0.4.5",
    "expo-system-ui": "~5.0.10",
    "expo-web-browser": "~14.2.0",
    "react": "19.0.0",
    "react-dom": "19.0.0",
    "react-native": "0.79.5",
    "react-native-gesture-handler": "~2.24.0",
    "react-native-reanimated": "~3.17.4",
    "react-native-safe-area-context": "5.4.0",
    "react-native-screens": "~4.11.1",
    "react-native-web": "~0.20.0",
    "react-native-webview": "13.13.5",
    "expo-file-system": "~18.1.11",
    "expo-sharing": "~13.1.5",
    "expo-document-picker": "~13.1.6",
    "@react-native-picker/picker": "2.11.1"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@types/react": "~19.0.10",
    "ajv": "^7.2.4",
    "eslint": "^9.25.0",
    "eslint-config-expo": "~9.2.0",
    "typescript": "~5.8.3"
  },
  "private": true
}


===============================================
File: reciation_log.json
===============================================

{
  "japa_history": [
    { "malas": 12, "date": "2025-08-01T07:30:00.000Z" },
    { "malas": 8, "date": "2025-08-02T07:45:00.000Z" },
    { "malas": 10, "date": "2025-08-03T08:00:00.000Z" },
    { "malas": 14, "date": "2025-08-04T07:50:00.000Z" },
    { "malas": 16, "date": "2025-08-05T08:15:00.000Z" },
    { "malas": 9, "date": "2025-08-06T07:20:00.000Z" },
    { "malas": 11, "date": "2025-08-07T08:10:00.000Z" },
    { "malas": 13, "date": "2025-08-08T07:40:00.000Z" },
    { "malas": 15, "date": "2025-08-09T08:05:00.000Z" },
    { "malas": 18, "date": "2025-08-10T07:55:00.000Z" },
    { "malas": 7, "date": "2025-08-11T08:20:00.000Z" },
    { "malas": 12, "date": "2025-08-12T07:35:00.000Z" },
    { "malas": 14, "date": "2025-08-13T08:00:00.000Z" },
    { "malas": 20, "date": "2025-08-14T07:45:00.000Z" },
    { "malas": 10, "date": "2025-08-15T08:30:00.000Z" },
    { "malas": 9, "date": "2025-08-16T07:50:00.000Z" },
    { "malas": 13, "date": "2025-08-17T08:10:00.000Z" },
    { "malas": 15, "date": "2025-08-18T07:55:00.000Z" },
    { "malas": 11, "date": "2025-08-19T08:25:00.000Z" },
    { "malas": 17, "date": "2025-08-20T07:40:00.000Z" },
    { "malas": 14, "date": "2025-08-21T08:05:00.000Z" },
    { "malas": 12, "date": "2025-08-22T07:50:00.000Z" }
  ],
  "recitation_log": [
    { "stotraId": "3", "stotraTitle": "Hanuman Chalisa", "count": 5, "date": "2025-08-01T19:00:00.000Z" },
    { "stotraId": "1", "stotraTitle": "Kāla Bhairava Aṣṭakam", "count": 3, "date": "2025-08-02T19:15:00.000Z" },
    { "stotraId": "2", "stotraTitle": "Abhinavagupta’s Bhairava Stotra", "count": 2, "date": "2025-08-03T19:30:00.000Z" },
    { "stotraId": "4", "stotraTitle": "Aṣṭottara Śatanāmāvalī of Baṭuka Bhairava", "count": 1, "date": "2025-08-04T19:00:00.000Z" },
    { "stotraId": "5", "stotraTitle": "Bhairava Tandava Stotra", "count": 2, "date": "2025-08-05T19:40:00.000Z" },
    { "stotraId": "3", "stotraTitle": "Hanuman Chalisa", "count": 4, "date": "2025-08-06T19:20:00.000Z" },
    { "stotraId": "1", "stotraTitle": "Kāla Bhairava Aṣṭakam", "count": 2, "date": "2025-08-07T19:10:00.000Z" },
    { "stotraId": "2", "stotraTitle": "Abhinavagupta’s Bhairava Stotra", "count": 1, "date": "2025-08-08T19:25:00.000Z" },
    { "stotraId": "4", "stotraTitle": "Aṣṭottara Śatanāmāvalī of Baṭuka Bhairava", "count": 2, "date": "2025-08-09T19:15:00.000Z" },
    { "stotraId": "5", "stotraTitle": "Bhairava Tandava Stotra", "count": 3, "date": "2025-08-10T19:35:00.000Z" },
    { "stotraId": "3", "stotraTitle": "Hanuman Chalisa", "count": 6, "date": "2025-08-11T19:00:00.000Z" },
    { "stotraId": "1", "stotraTitle": "Kāla Bhairava Aṣṭakam", "count": 3, "date": "2025-08-12T19:20:00.000Z" },
    { "stotraId": "2", "stotraTitle": "Abhinavagupta’s Bhairava Stotra", "count": 2, "date": "2025-08-13T19:30:00.000Z" },
    { "stotraId": "4", "stotraTitle": "Aṣṭottara Śatanāmāvalī of Baṭuka Bhairava", "count": 1, "date": "2025-08-14T19:00:00.000Z" },
    { "stotraId": "5", "stotraTitle": "Bhairava Tandava Stotra", "count": 2, "date": "2025-08-15T19:40:00.000Z" },
    { "stotraId": "3", "stotraTitle": "Hanuman Chalisa", "count": 7, "date": "2025-08-16T19:10:00.000Z" },
    { "stotraId": "1", "stotraTitle": "Kāla Bhairava Aṣṭakam", "count": 4, "date": "2025-08-17T19:20:00.000Z" },
    { "stotraId": "2", "stotraTitle": "Abhinavagupta’s Bhairava Stotra", "count": 1, "date": "2025-08-18T19:15:00.000Z" },
    { "stotraId": "4", "stotraTitle": "Aṣṭottara Śatanāmāvalī of Baṭuka Bhairava", "count": 2, "date": "2025-08-19T19:00:00.000Z" },
    { "stotraId": "5", "stotraTitle": "Bhairava Tandava Stotra", "count": 3, "date": "2025-08-20T19:25:00.000Z" },
    { "stotraId": "3", "stotraTitle": "Hanuman Chalisa", "count": 5, "date": "2025-08-21T19:35:00.000Z" },
    { "stotraId": "1", "stotraTitle": "Kāla Bhairava Aṣṭakam", "count": 2, "date": "2025-08-22T19:00:00.000Z" }
  ],
  "gratitude_notes": [
    { "note": "Grateful for a peaceful start to the month.", "date": "2025-08-01T21:00:00.000Z" },
    { "note": "Deep devotion felt while chanting Hanuman Chalisa.", "date": "2025-08-06T21:10:00.000Z" },
    { "note": "Thankful for clarity on Independence Day.", "date": "2025-08-15T21:20:00.000Z" },
    { "note": "Blessed with calmness in evening recitations.", "date": "2025-08-20T21:30:00.000Z" }
  ],
  "goals_list": [
    {
      "id": "1716307200000",
      "type": "spiritual",
      "title": "Imported Spiritual Goal",
      "isCompleted": true
    },
    {
      "id": "1716307200001",
      "type": "material",
      "title": "Imported Material Goal",
      "isCompleted": false
    },
    {
      "id": "1722470400000",
      "type": "spiritual",
      "title": "Chant 500 malas in August",
      "isCompleted": false
    },
    {
      "id": "1722470500000",
      "type": "personal",
      "title": "Daily stotra recitation in August",
      "isCompleted": true
    }
  ]
}


===============================================
File: tsconfig.json
===============================================

{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    ".expo/types/**/*.ts",
    "expo-env.d.ts"
  ]
}


===============================================
File: app\+not-found.tsx
===============================================

import { Ionicons } from '@expo/vector-icons';
import { Link, Stack } from 'expo-router';
import { StyleSheet, Text, TouchableOpacity, View } from 'react-native';

export default function NotFoundScreen() {
  return (
    <>
      <Stack.Screen options={{ title: 'Page Not Found' }} />
      <View style={styles.container}>
        <Ionicons name="alert-circle-outline" size={80} color="#FF6B6B" />
        <Text style={styles.title}>404</Text>
        <Text style={styles.message}>The page you&apos;re looking for doesn&apos;t exist</Text>
        <TouchableOpacity>
          <Link href="/" style={styles.link}>
            <View style={styles.buttonContainer}>
              <Ionicons name="home-outline" size={20} color="white" />
              <Text style={styles.buttonText}>Return to Home</Text>
            </View>
          </Link>
        </TouchableOpacity>
      </View>
    </>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 20,
    backgroundColor: '#f8f9fa',
  },
  title: {
    fontSize: 72,
    fontWeight: 'bold',
    marginVertical: 10,
    color: '#343a40',
  },
  message: {
    fontSize: 18,
    marginBottom: 30,
    color: '#6c757d',
    textAlign: 'center',
  },
  link: {
    marginTop: 15,
  },
  buttonContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#4263EB',
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 8,
  },
  buttonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: '600',
    marginLeft: 8,
  },
});


===============================================
File: app\(tabs)\goals.tsx
===============================================

/*
 * =================================================================
 * NEW FILE: /app/(tabs)/goals.tsx
 * The main screen for displaying and managing goals.
 * =================================================================
 */
import AddGoalModal from '@/components/AddGoalModal';
import { Goal, StorageService } from '@/services/StorageService';
import { Ionicons } from '@expo/vector-icons';
import { useFocusEffect } from 'expo-router';
import React, { useCallback, useState } from 'react';
import { Alert, FlatList, Platform, SafeAreaView, StatusBar, StyleSheet, Text, TouchableOpacity, View } from 'react-native';

const GoalItem = ({ item, onToggle, onDelete }: { item: Goal, onToggle: (id: string, status: boolean) => void, onDelete: (id: string) => void }) => (
    <View style={goalStyles.goalItem}>
        <TouchableOpacity onPress={() => onToggle(item.id, !item.isCompleted)} style={goalStyles.checkbox}>
            {item.isCompleted && <Ionicons name="checkmark" size={20} color="#FF6D00" />}
        </TouchableOpacity>
        <Text style={[goalStyles.goalTitle, item.isCompleted && goalStyles.goalTitleCompleted]}>{item.title}</Text>
        <TouchableOpacity onPress={() => onDelete(item.id)}>
            <Ionicons name="trash-outline" size={24} color="#555" />
        </TouchableOpacity>
    </View>
);

export default function GoalsScreen() {
    const [goals, setGoals] = useState<Goal[]>([]);
    const [modalVisible, setModalVisible] = useState(false);

    const loadGoals = async () => {
        const storedGoals = await StorageService.getGoals();
        setGoals(storedGoals);
    };

    useFocusEffect(useCallback(() => {
        loadGoals();
    }, []));

    const handleToggleGoal = async (id: string, status: boolean) => {
        await StorageService.updateGoalStatus(id, status);
        loadGoals();
    };

    const handleDeleteGoal = (id: string) => {
        Alert.alert("Delete Goal", "Are you sure you want to delete this goal?", [
            { text: "Cancel", style: "cancel" },
            { text: "Delete", style: "destructive", onPress: async () => {
                await StorageService.deleteGoal(id);
                loadGoals();
            }},
        ]);
    };

    const handleSaveGoal = async (goal: Goal) => {
        await StorageService.saveGoal(goal);
        loadGoals();
    };

    const spiritualGoals = goals.filter(g => g.type === 'spiritual');
    const materialGoals = goals.filter(g => g.type === 'material');

    return (
        <SafeAreaView style={goalStyles.container}>
            <StatusBar 
                barStyle="light-content" 
                backgroundColor="#121212" 
                translucent={false}
            />
            <AddGoalModal visible={modalVisible} onClose={() => setModalVisible(false)} onSave={handleSaveGoal} />
            <View style={goalStyles.header}>
                <Text style={goalStyles.headerTitle}>My Saṅkalpas</Text>
                <TouchableOpacity onPress={() => setModalVisible(true)}>
                    <Ionicons name="add-circle" size={32} color="#FF6D00" />
                </TouchableOpacity>
            </View>

            <Text style={goalStyles.sectionTitle}>Spiritual Goals</Text>
            <FlatList
                data={spiritualGoals}
                keyExtractor={item => item.id}
                renderItem={({ item }) => <GoalItem item={item} onToggle={handleToggleGoal} onDelete={handleDeleteGoal} />}
                ListEmptyComponent={<Text style={goalStyles.emptyText}>No spiritual goals set.</Text>}
            />

            <Text style={goalStyles.sectionTitle}>Material Goals</Text>
            <FlatList
                data={materialGoals}
                keyExtractor={item => item.id}
                renderItem={({ item }) => <GoalItem item={item} onToggle={handleToggleGoal} onDelete={handleDeleteGoal} />}
                ListEmptyComponent={<Text style={goalStyles.emptyText}>No material goals set.</Text>}
            />
        </SafeAreaView>
    );
}

const goalStyles = StyleSheet.create({
    container: { 
        flex: 1, 
        backgroundColor: '#121212', 
        padding: 20,
        paddingTop: Platform.OS === 'android' ? (StatusBar.currentHeight || 0) + 20 : 20,
    },
    header: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', marginBottom: 20 },
    headerTitle: { fontSize: 28, fontWeight: 'bold', color: '#FFFFFF' },
    sectionTitle: { fontSize: 22, fontWeight: '600', color: '#FF6D00', marginTop: 20, marginBottom: 10, borderBottomColor: '#333', borderBottomWidth: 1, paddingBottom: 5 },
    goalItem: { flexDirection: 'row', alignItems: 'center', backgroundColor: '#1E1E1E', padding: 15, borderRadius: 10, marginVertical: 5 },
    checkbox: { width: 28, height: 28, borderRadius: 5, borderWidth: 2, borderColor: '#555', justifyContent: 'center', alignItems: 'center', marginRight: 15 },
    goalTitle: { flex: 1, fontSize: 16, color: '#FFFFFF' },
    goalTitleCompleted: { textDecorationLine: 'line-through', color: '#666' },
    emptyText: { color: '#666', fontStyle: 'italic', textAlign: 'center', marginTop: 10 },
});

===============================================
File: app\(tabs)\index.tsx
===============================================

/*
 * =================================================================
 * File: /app/(tabs)/index.tsx (Create this file)
 * This handles the default redirection to the Japa screen.
 * =================================================================
 */
import { Redirect } from 'expo-router';
export default function TabIndex() {
  return <Redirect href={'/(tabs)/japa'} />;
}

===============================================
File: app\(tabs)\insights.tsx
===============================================

import { JapaSession, RecitationLog, StorageService } from '@/services/StorageService';
import { Ionicons } from '@expo/vector-icons';
import * as DocumentPicker from 'expo-document-picker';
import * as FileSystem from 'expo-file-system';
import { useFocusEffect } from 'expo-router';
import * as Sharing from 'expo-sharing';
import React, { useCallback, useState } from 'react';
import { Alert, LayoutAnimation, Platform, SafeAreaView, ScrollView, StatusBar, StyleSheet, Text, TouchableOpacity, UIManager, View } from 'react-native';

// Enable LayoutAnimation on Android
if (Platform.OS === 'android' && UIManager.setLayoutAnimationEnabledExperimental) {
    UIManager.setLayoutAnimationEnabledExperimental(true);
}

// --- Types for our state ---
type Timeframe = 'weekly' | 'lifetime';
type PracticeType = 'japa' | 'recitations';

interface JapaData {
    total: number;
    dailyCounts: number[]; // For the weekly chart
}
interface RecitationData {
    summary: { [key: string]: number };
}

// --- A Simple Bar Chart Component ---
const SimpleBarChart = ({ data, color }: { data: number[], color: string }) => {
    const maxValue = Math.max(...data, 1); // Avoid division by zero
    return (
        <View style={styles.chartContainer}>
            {data.map((value, index) => (
                <View key={index} style={styles.barWrapper}>
                    <View style={[styles.bar, { height: `${(value / maxValue) * 100}%`, backgroundColor: color }]} />
                </View>
            ))}
        </View>
    );
};

export default function InsightsScreen() {
    // --- State Management ---
    const [timeframe, setTimeframe] = useState<Timeframe>('weekly');
    const [practiceType, setPracticeType] = useState<PracticeType>('japa');
    const [streak, setStreak] = useState(0);

    // State to hold all calculated data
    const [weeklyJapa, setWeeklyJapa] = useState<JapaData>({ total: 0, dailyCounts: [] });
    const [lifetimeJapa, setLifetimeJapa] = useState<JapaData>({ total: 0, dailyCounts: [] });
    const [weeklyRecitations, setWeeklyRecitations] = useState<RecitationData>({ summary: {} });
    const [lifetimeRecitations, setLifetimeRecitations] = useState<RecitationData>({ summary: {} });
    
    // --- Data Calculation Logic ---
    const calculateInsights = async () => {
        const japaHistory: JapaSession[] = await StorageService.getJapaHistory();
        const recitationLogs: RecitationLog[] = await StorageService.getRecitationLogs();
        const oneWeekAgo = new Date();
        oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);

        // --- Lifetime Calculations ---
        const lifeJapaTotal = japaHistory.reduce((sum, item) => sum + item.malas, 0);
        const lifeRecitationSummary: { [key: string]: number } = {};
        recitationLogs.forEach(log => { lifeRecitationSummary[log.stotraTitle] = (lifeRecitationSummary[log.stotraTitle] || 0) + log.count; });

        setLifetimeJapa({ total: lifeJapaTotal, dailyCounts: [] });
        setLifetimeRecitations({ summary: lifeRecitationSummary });

        // --- Weekly Calculations ---
        const weeklyJapaLogs = japaHistory.filter(j => new Date(j.date) >= oneWeekAgo);
        const weeklyRecitationLogs = recitationLogs.filter(r => new Date(r.date) >= oneWeekAgo);
        
        // Weekly Japa total and chart data
        const weekJapaTotal = weeklyJapaLogs.reduce((sum, item) => sum + item.malas, 0);
        const dailyJapaCounts = Array(7).fill(0);
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        weeklyJapaLogs.forEach(log => {
            const logDate = new Date(log.date);
            logDate.setHours(0, 0, 0, 0);
            const diffDays = Math.round((today.getTime() - logDate.getTime()) / (1000 * 60 * 60 * 24));
            if (diffDays >= 0 && diffDays < 7) {
                dailyJapaCounts[6 - diffDays] += log.malas;
            }
        });
        setWeeklyJapa({ total: weekJapaTotal, dailyCounts: dailyJapaCounts });

        // Weekly Recitation summary
        const weekRecitationSummary: { [key: string]: number } = {};
        weeklyRecitationLogs.forEach(log => { weekRecitationSummary[log.stotraTitle] = (weekRecitationSummary[log.stotraTitle] || 0) + log.count; });
        setWeeklyRecitations({ summary: weekRecitationSummary });
        
        // --- Streak Calculation ---
        const allPracticeDates = new Set(japaHistory.map(j => new Date(j.date).toISOString().split('T')[0]));
        recitationLogs.forEach(r => allPracticeDates.add(new Date(r.date).toISOString().split('T')[0]));
        let currentStreak = 0;
        let checkDate = new Date();
        while (allPracticeDates.has(checkDate.toISOString().split('T')[0])) {
            currentStreak++;
            checkDate.setDate(checkDate.getDate() - 1);
        }
        setStreak(currentStreak);
    };

    useFocusEffect(useCallback(() => { calculateInsights(); }, []));

    // --- NEW: Export/Import Handlers ---
    const handleExport = async () => {
        try {
            const data = await StorageService.exportAllData();
            const jsonString = JSON.stringify(data, null, 2); // Pretty print JSON
            const filename = `SadhnaFlow_Backup_${new Date().toISOString().split('T')[0]}.json`;
            const uri = FileSystem.cacheDirectory + filename;

            await FileSystem.writeAsStringAsync(uri, jsonString);
            await Sharing.shareAsync(uri, { mimeType: 'application/json', dialogTitle: 'Save your SadhnaFlow progress' });
            
        } catch (error) {
            console.error(error);
            Alert.alert("Export Failed", "Could not export your progress. Please try again.");
        }
    };

    const handleImport = async () => {
        Alert.alert(
            "Import Progress",
            "This will overwrite all current progress in the app. This action cannot be undone. Are you sure you want to continue?",
            [
                { text: "Cancel", style: "cancel" },
                { text: "Import", style: "destructive", onPress: async () => {
                    try {
                        const result = await DocumentPicker.getDocumentAsync({ type: 'application/json' });
                        if (result.canceled === false && result.assets && result.assets[0].uri) {
                            const jsonString = await FileSystem.readAsStringAsync(result.assets[0].uri);
                            const data = JSON.parse(jsonString);

                            await StorageService.importAllData(data);
                            
                            // Refresh the screen with new data
                            await calculateInsights();
                            Alert.alert("Import Successful", "Your progress has been restored.");
                        }
                    } catch (error) {
                        console.error(error);
                        Alert.alert("Import Failed", "The file was invalid or corrupted. Please make sure you are using a valid backup file.");
                    }
                }},
            ]
        );
    };

    const handleTimeframeChange = (newTimeframe: Timeframe) => {
        LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
        setTimeframe(newTimeframe);
    };

    const handlePracticeTypeChange = (newType: PracticeType) => {
        LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
        setPracticeType(newType);
    };

    const renderContent = () => {
        if (timeframe === 'weekly') {
            if (practiceType === 'japa') {
                return (
                    <View style={styles.metricContainer}>
                        <Text style={[styles.metricValue, { color: '#FF8A65' }]}>{weeklyJapa.total}</Text>
                        <Text style={styles.metricLabel}>Total Mālās Recited This Week</Text>
                        <SimpleBarChart data={weeklyJapa.dailyCounts} color="#FF8A65" />
                        <Text style={styles.chartLabel}>Last 7 Days</Text>
                    </View>
                );
            } else { // Recitations
                const recitations = Object.entries(weeklyRecitations.summary);
                return (
                    <View style={styles.metricContainer}>
                        {recitations.length > 0 ? (
                            recitations.map(([title, count]) => (
                                <View key={title} style={styles.recitationRow}>
                                    {/* FIX: Truncate long text */}
                                    <Text style={styles.recitationTitle} numberOfLines={1} ellipsizeMode="tail">{title}</Text>
                                    <Text style={[styles.recitationCount, { color: '#4DB6AC' }]}>{count} times</Text>
                                </View>
                            ))
                        ) : <Text style={styles.noDataText}>No recitations logged this week.</Text>}
                    </View>
                );
            }
        } else { // Lifetime
            if (practiceType === 'japa') {
                return (
                    <View style={styles.metricContainer}>
                        <Text style={[styles.metricValue, { color: '#FF8A65' }]}>{lifetimeJapa.total}</Text>
                        <Text style={styles.metricLabel}>Total Mālās Recited All Time</Text>
                    </View>
                );
            } else { // Recitations
                 const recitations = Object.entries(lifetimeRecitations.summary)
                    .sort(([, a], [, b]) => b - a).slice(0, 5);
                return (
                    <View style={styles.metricContainer}>
                        {recitations.length > 0 ? (
                            <>
                                <Text style={styles.topStotrasLabel}>Top Recitations All Time</Text>
                                {recitations.map(([title, count]) => (
                                    <View key={title} style={styles.recitationRow}>
                                        <Text style={styles.recitationTitle} numberOfLines={1} ellipsizeMode="tail">{title}</Text>
                                        <Text style={[styles.recitationCount, { color: '#4DB6AC' }]}>{count} times</Text>
                                    </View>
                                ))}
                            </>
                        ) : <Text style={styles.noDataText}>No recitations logged yet.</Text>}
                    </View>
                );
            }
        }
    };

    return (
        <SafeAreaView style={styles.container}>
            <StatusBar barStyle="light-content" backgroundColor="#121212" />
            <ScrollView contentContainerStyle={styles.scrollContainer}>
                <View style={styles.headerContainer}>
                    <Text style={styles.header}>Insights</Text>
                    <Text style={styles.subHeader}>Your journey so far</Text>
                </View>
                
                <View style={styles.card}>
                    <Text style={styles.cardTitle}>Current Streak</Text>
                    <View style={styles.streakContainer}>
                        <View style={styles.streakCircle}>
                            <Ionicons name="flame" size={40} color="#FFB74D" />
                            <Text style={styles.streakNumber}>{streak}</Text>
                        </View>
                    </View>
                    <Text style={styles.streakLabel}>Consecutive days of practice</Text>
                </View>
                
                <View style={styles.card}>
                    <View style={styles.toggleContainer}>
                        <TouchableOpacity onPress={() => handleTimeframeChange('weekly')} style={[styles.toggleButton, timeframe === 'weekly' && styles.toggleButtonActive]}>
                            <Text style={[styles.toggleButtonText, timeframe === 'weekly' && styles.toggleButtonTextActive]}>Weekly</Text>
                        </TouchableOpacity>
                        <TouchableOpacity onPress={() => handleTimeframeChange('lifetime')} style={[styles.toggleButton, timeframe === 'lifetime' && styles.toggleButtonActive]}>
                            <Text style={[styles.toggleButtonText, timeframe === 'lifetime' && styles.toggleButtonTextActive]}>Lifetime</Text>
                        </TouchableOpacity>
                    </View>
                    
                    <View style={[styles.tabsContainer, practiceType === 'japa' ? styles.japaTabBackground : styles.recitationTabBackground]}>
                        <TouchableOpacity onPress={() => handlePracticeTypeChange('japa')} style={[styles.tabButton, practiceType === 'japa' && styles.tabButtonActive]}>
                            <Ionicons name="sync-circle-outline" size={18} color={practiceType === 'japa' ? '#FF8A65' : '#FFF'} style={{marginRight: 5}}/>
                            <Text style={[styles.tabButtonText, practiceType === 'japa' && { color: '#FF8A65'}]}>Japa</Text>
                        </TouchableOpacity>
                        <TouchableOpacity onPress={() => handlePracticeTypeChange('recitations')} style={[styles.tabButton, practiceType === 'recitations' && styles.tabButtonActive]}>
                            <Ionicons name="book-outline" size={18} color={practiceType === 'recitations' ? '#4DB6AC' : '#FFF'} style={{marginRight: 5}}/>
                            <Text style={[styles.tabButtonText, practiceType === 'recitations' && { color: '#4DB6AC'}]}>Recitations</Text>
                        </TouchableOpacity>
                    </View>
                    
                    {renderContent()}
                    
                    <Text style={styles.cardFooterText}>Switch above to compare Japa and Recitations over time.</Text>
                </View>

                <View style={styles.card}>
                    <Text style={styles.cardTitle}>Data Management</Text>
                    <Text style={styles.dataManagementText}>
                        Save your progress to a file to restore it on a new device.
                    </Text>
                    <View style={styles.dataButtonsContainer}>
                        <TouchableOpacity style={styles.dataButton} onPress={handleExport}>
                            <Ionicons name="cloud-upload-outline" size={18} color="#81C784" />
                            <Text style={styles.dataButtonText}>Export Progress</Text>
                        </TouchableOpacity>
                        <TouchableOpacity style={styles.dataButton} onPress={handleImport}>
                            <Ionicons name="cloud-download-outline" size={18} color="#64B5F6" />
                            <Text style={styles.dataButtonText}>Import Progress</Text>
                        </TouchableOpacity>
                    </View>
                </View>
            </ScrollView>
        </SafeAreaView>
    );
}

const styles = StyleSheet.create({
    container: { flex: 1, backgroundColor: '#121212' },
    scrollContainer: { padding: 20, paddingBottom: 40 },
    headerContainer: { alignItems: 'center', marginBottom: 20 },
    header: { fontSize: 32, fontWeight: 'bold', color: '#FFFFFF' },
    subHeader: { fontSize: 16, color: '#A0A0A0', marginTop: 4 },
    card: { backgroundColor: '#1E1E1E', borderRadius: 15, padding: 20, marginBottom: 20 },
    cardTitle: { fontSize: 20, fontWeight: '600', color: '#FFD700', marginBottom: 15, textAlign: 'center' },
    streakContainer: { alignItems: 'center', marginVertical: 10 },
    streakCircle: { width: 120, height: 120, borderRadius: 60, backgroundColor: '#2C2C2C', justifyContent: 'center', alignItems: 'center', position: 'relative' },
    streakNumber: { fontSize: 48, fontWeight: 'bold', color: '#FFFFFF' },
    streakLabel: { fontSize: 16, color: '#A0A0A0', textAlign: 'center', marginTop: 10 },
    toggleContainer: { flexDirection: 'row', backgroundColor: '#333', borderRadius: 20, padding: 4, marginBottom: 15 },
    toggleButton: { flex: 1, paddingVertical: 8, borderRadius: 16, alignItems: 'center' },
    toggleButtonActive: { backgroundColor: '#555' },
    toggleButtonText: { color: '#A0A0A0', fontWeight: '600' },
    toggleButtonTextActive: { color: '#FFFFFF' },
    tabsContainer: { flexDirection: 'row', borderRadius: 10, padding: 4, marginBottom: 20 },
    japaTabBackground: { backgroundColor: 'rgba(255, 138, 101, 0.1)' },
    recitationTabBackground: { backgroundColor: 'rgba(77, 182, 172, 0.1)' },
    tabButton: { flex: 1, flexDirection: 'row', paddingVertical: 10, borderRadius: 8, alignItems: 'center', justifyContent: 'center' },
    tabButtonActive: { backgroundColor: '#1E1E1E' },
    tabButtonText: { color: '#FFF', fontWeight: 'bold', fontSize: 16 },
    metricContainer: { minHeight: 150, justifyContent: 'center', alignItems: 'center' },
    metricValue: { fontSize: 48, fontWeight: 'bold', textAlign: 'center' },
    metricLabel: { fontSize: 16, color: '#A0A0A0', textAlign: 'center', marginTop: 5, marginBottom: 15 },
    recitationRow: { width: '100%', flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', paddingVertical: 10, borderBottomWidth: 1, borderBottomColor: '#333' },
    recitationTitle: { fontSize: 16, color: '#E0E0E0', flexShrink: 1, marginRight: 10 }, // flexShrink allows text to shrink
    recitationCount: { fontSize: 16, fontWeight: 'bold' },
    topStotrasLabel: { fontSize: 16, color: '#A0A0A0', marginBottom: 10 },
    noDataText: { fontSize: 16, color: '#A0A0A0', textAlign: 'center', fontStyle: 'italic', paddingVertical: 20 },
    cardFooterText: { fontSize: 12, color: '#666', textAlign: 'center', marginTop: 20, fontStyle: 'italic' },
    chartContainer: { flexDirection: 'row', height: 80, width: '90%', justifyContent: 'center', alignItems: 'flex-end', marginTop: 10, gap: 8 },
    barWrapper: { flex: 1, height: '100%', justifyContent: 'flex-end' },
    bar: { width: '100%', borderTopLeftRadius: 4, borderTopRightRadius: 4 },
    chartLabel: { fontSize: 12, color: '#666', marginTop: 5 },
    dataManagementText: { color: '#A0A0A0', textAlign: 'center', fontSize: 14, marginBottom: 20, lineHeight: 20 },
    dataButtonsContainer: { flexDirection: 'row', justifyContent: 'center', gap: 15 },
    dataButton: { flexDirection: 'row', alignItems: 'center', backgroundColor: '#333', paddingVertical: 12, paddingHorizontal: 16, borderRadius: 10 },
    dataButtonText: { color: '#FFFFFF', fontWeight: '600', marginLeft: 12, fontSize: 14 },
});

===============================================
File: app\(tabs)\japa.tsx
===============================================

import JapaCounter from '@/components/JapaCounter';
import MonthYearPickerModal from '@/components/MonthYearPickerModal';
import { JapaSession, RecitationLog, StorageService } from '@/services/StorageService';
import { Ionicons } from '@expo/vector-icons';
import { useFocusEffect } from 'expo-router';
import React, { useCallback, useMemo, useState } from 'react';
import { Alert, FlatList, LayoutAnimation, Platform, SafeAreaView, StatusBar, StyleSheet, Text, TouchableOpacity, UIManager, View } from 'react-native';

if (Platform.OS === 'android' && UIManager.setLayoutAnimationEnabledExperimental) {
  UIManager.setLayoutAnimationEnabledExperimental(true);
}

type HistoryTab = 'japa' | 'recitations';

export default function JapaScreen() {
  const [activeTab, setActiveTab] = useState<HistoryTab>('japa');
  const [currentDate, setCurrentDate] = useState(new Date());
  const [allJapaHistory, setAllJapaHistory] = useState<JapaSession[]>([]);
  const [allRecitationHistory, setAllRecitationHistory] = useState<RecitationLog[]>([]);
  const [isPickerVisible, setIsPickerVisible] = useState(false);
  const [isHistoryExpanded, setIsHistoryExpanded] = useState(false);

  const loadAllHistory = async () => {
    const japaData = await StorageService.getJapaHistory();
    const recitationData = await StorageService.getRecitationLogs();
    setAllJapaHistory(japaData);
    setAllRecitationHistory(recitationData);
  };

  useFocusEffect(useCallback(() => { loadAllHistory(); }, []));

  const filteredHistory = useMemo(() => {
    const targetMonth = currentDate.getMonth();
    const targetYear = currentDate.getFullYear();

    if (activeTab === 'japa') {
      return allJapaHistory.filter(item => {
        const itemDate = new Date(item.date);
        return itemDate.getMonth() === targetMonth && itemDate.getFullYear() === targetYear;
      });
    } else {
      return allRecitationHistory.filter(item => {
        const itemDate = new Date(item.date);
        return itemDate.getMonth() === targetMonth && itemDate.getFullYear() === targetYear;
      });
    }
  }, [activeTab, currentDate, allJapaHistory, allRecitationHistory]);

  const handleMonthChange = (direction: 'prev' | 'next') => {
    setCurrentDate(prevDate => {
      const newDate = new Date(prevDate);
      newDate.setDate(1);
      newDate.setMonth(newDate.getMonth() + (direction === 'prev' ? -1 : 1));
      return newDate;
    });
  };
  
  const handleDateSelect = (newDate: Date) => {
    setCurrentDate(newDate);
  };

  const handleDeleteJapa = (item: JapaSession) => {
    Alert.alert("Delete Japa Log", `Delete the log of ${item.malas} mālā(s) from ${new Date(item.date).toLocaleDateString()}?`, [
      { text: "Cancel", style: "cancel" },
      { text: "Delete", style: "destructive", onPress: async () => {
          await StorageService.deleteJapaSession(item.date);
          loadAllHistory();
        }},
    ]);
  };

  const handleDeleteRecitation = (item: RecitationLog) => {
    Alert.alert("Delete Recitation Log", `Delete the log of ${item.count} recitation(s) of "${item.stotraTitle}"?`, [
        { text: "Cancel", style: "cancel" },
        { text: "Delete", style: "destructive", onPress: async () => {
            await StorageService.deleteRecitationLog(item.date);
            loadAllHistory();
        }},
    ]);
  };

  const toggleHistoryExpansion = () => {
    LayoutAnimation.configureNext({
      duration: 400,
      create: {
        type: LayoutAnimation.Types.easeInEaseOut,
        property: LayoutAnimation.Properties.opacity,
        duration: 200,
      },
      update: {
        type: LayoutAnimation.Types.spring,
        springDamping: 0.8,
      },
    });
    setIsHistoryExpanded(!isHistoryExpanded);
  };

  const formattedDate = currentDate.toLocaleString('default', { month: 'long', year: 'numeric' });

  return (
    <SafeAreaView style={styles.container}>
      <StatusBar barStyle="light-content" backgroundColor="#121212" />
      
      {/* Dynamic Japa Counter Section */}
      <View style={[
        styles.counterSection, 
        isHistoryExpanded ? styles.counterSectionCompact : styles.counterSectionExpanded
      ]}>
        <JapaCounter 
          onJapaSaved={loadAllHistory} 
          isCompact={isHistoryExpanded}
        />
      </View>
      
      {/* Collapsible History Section */}
      <View style={[
        styles.historySection,
        isHistoryExpanded ? styles.historySectionExpanded : styles.historySectionCollapsed
      ]}>
        {/* History Header - Always Visible */}
        <TouchableOpacity 
          style={styles.historyHeader} 
          onPress={toggleHistoryExpansion}
          activeOpacity={0.7}
        >
          <Text style={styles.mainHistoryTitle}>Practice History</Text>
          <Ionicons 
            name={isHistoryExpanded ? "chevron-up" : "chevron-down"} 
            size={24} 
            color="#FF6D00" 
          />
        </TouchableOpacity>

        {/* Expandable History Content */}
        {isHistoryExpanded && (
          <>
            <View style={styles.monthNavigator}>
              <TouchableOpacity onPress={() => handleMonthChange('prev')} style={styles.arrowButton}>
                <Ionicons name="chevron-back" size={24} color="#FF6D00" />
              </TouchableOpacity>
              <TouchableOpacity onPress={() => setIsPickerVisible(true)}>
                <Text style={styles.monthText}>{formattedDate}</Text>
              </TouchableOpacity>
              <TouchableOpacity onPress={() => handleMonthChange('next')} style={styles.arrowButton}>
                <Ionicons name="chevron-forward" size={24} color="#FF6D00" />
              </TouchableOpacity>
            </View>

            <View style={styles.tabContainer}>
              <TouchableOpacity 
                style={[styles.tabButton, activeTab === 'japa' && styles.activeTab]} 
                onPress={() => setActiveTab('japa')}>
                <Text style={[styles.tabText, activeTab === 'japa' && styles.activeTabText]}>Japa</Text>
              </TouchableOpacity>
              <TouchableOpacity 
                style={[styles.tabButton, activeTab === 'recitations' && styles.activeTab]} 
                onPress={() => setActiveTab('recitations')}>
                <Text style={[styles.tabText, activeTab === 'recitations' && styles.activeTabText]}>Recitations</Text>
              </TouchableOpacity>
            </View>
            
            {/* History List */}
            <View style={styles.listContainer}>
              <FlatList 
                data={filteredHistory} 
                keyExtractor={(item) => item.date}
                showsVerticalScrollIndicator={false}
                contentContainerStyle={styles.listContent}
                ListEmptyComponent={
                  <View style={styles.emptyContainer}>
                    <Text style={styles.emptyText}>
                      No {activeTab} logged for {formattedDate}.
                    </Text>
                  </View>
                } 
                renderItem={({ item }) => (
                  activeTab === 'japa' ? (
                    <View style={styles.historyItem}>
                      <View style={styles.historyItemContent}>
                        <Text style={styles.historyText}>{(item as JapaSession).malas} mālā(s)</Text>
                        <Text style={styles.historyDate}>{new Date(item.date).toLocaleString()}</Text>
                      </View>
                      <TouchableOpacity onPress={() => handleDeleteJapa(item as JapaSession)} style={styles.deleteButton}>
                        <Ionicons name="trash-bin-outline" size={20} color="#888" />
                      </TouchableOpacity>
                    </View>
                  ) : (
                    <View style={styles.historyItem}>
                      <View style={styles.historyItemContent}>
                        <Text style={styles.historyText} numberOfLines={1} ellipsizeMode='tail'>
                          {(item as RecitationLog).stotraTitle}
                        </Text>
                        <Text style={styles.historyDate}>
                          {(item as RecitationLog).count} time(s) on {new Date(item.date).toLocaleDateString()}
                        </Text>
                      </View>
                      <TouchableOpacity onPress={() => handleDeleteRecitation(item as RecitationLog)} style={styles.deleteButton}>
                        <Ionicons name="trash-bin-outline" size={20} color="#888" />
                      </TouchableOpacity>
                    </View>
                  )
                )} 
              />
            </View>
          </>
        )}
      </View>

      <MonthYearPickerModal 
        visible={isPickerVisible}
        initialDate={currentDate}
        onClose={() => setIsPickerVisible(false)}
        onSelect={handleDateSelect}
      />
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: { 
    flex: 1, 
    backgroundColor: '#121212',
    paddingTop: Platform.OS === 'android' ? StatusBar.currentHeight : 0,
  },
  
  // Dynamic counter section
  counterSection: {
    flex: 0,
  },
  
  counterSectionExpanded: {
    flex: 0.8, // Takes 80% of the screen when history is collapsed
    minHeight: 500,
  },
  
  counterSectionCompact: {
    flex: 0,
    minHeight: 280, // Smaller height when history is expanded
  },
  
  // Dynamic history section
  historySection: {
    borderTopWidth: 1,
    borderTopColor: '#333',
  },
  
  historySectionCollapsed: {
    flex: 0.2, // Takes only 20% when collapsed
    minHeight: 60, // Just enough for the header
  },
  
  historySectionExpanded: {
    flex: 1, // Take remaining space when expanded
  },
  
  // History header (always visible)
  historyHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingVertical: 18,
    backgroundColor: '#1A1A1A',
    borderRadius: 12,
    marginHorizontal: 15,
    marginTop: 10,
    elevation: 3,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.15,
    shadowRadius: 4,
  },
  
  mainHistoryTitle: { 
    fontSize: 20, 
    fontWeight: 'bold', 
    color: '#FFFFFF',
  },
  
  monthNavigator: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingVertical: 8,
  },
  
  arrowButton: {
    padding: 8,
  },
  
  monthText: {
    fontSize: 18,
    fontWeight: '600',
    color: '#FFFFFF',
    textDecorationLine: 'underline',
    textDecorationStyle: 'dotted',
  },
  
  tabContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    marginHorizontal: 20,
    marginVertical: 15,
    backgroundColor: '#1E1E1E',
    borderRadius: 10,
    padding: 3,
  },
  
  tabButton: {
    flex: 1,
    paddingVertical: 10,
    borderRadius: 8,
    alignItems: 'center',
  },
  
  activeTab: {
    backgroundColor: '#FF6D00',
  },
  
  tabText: {
    color: '#A0A0A0',
    fontWeight: 'bold',
    fontSize: 14,
  },
  
  activeTabText: {
    color: '#FFFFFF',
  },
  
  listContainer: {
    flex: 1,
    paddingHorizontal: 15,
  },
  
  listContent: {
    flexGrow: 1,
    paddingBottom: 20,
  },
  
  historyItem: { 
    flexDirection: 'row', 
    justifyContent: 'space-between', 
    alignItems: 'center',
    backgroundColor: '#1E1E1E', 
    paddingVertical: 16,
    paddingHorizontal: 16,
    marginVertical: 4,
    borderRadius: 12,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
  },
  
  historyItemContent: {
    flex: 1,
  },
  
  historyText: { 
    color: '#E0E0E0', 
    fontSize: 16,
    fontWeight: '600',
  },
  
  historyDate: { 
    color: '#A0A0A0', 
    fontSize: 13,
    marginTop: 4,
  },
  
  deleteButton: {
    padding: 8,
    marginLeft: 10,
    borderRadius: 8,
  },
  
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: 60,
  },
  
  emptyText: { 
    color: '#A0A0A0', 
    fontStyle: 'italic',
    textAlign: 'center',
    fontSize: 16,
  },
});

===============================================
File: app\(tabs)\journal.tsx
===============================================

import MonthYearPickerModal from '@/components/MonthYearPickerModal';
import { GratitudeNote, StorageService } from '@/services/StorageService';
import { Ionicons } from '@expo/vector-icons';
import { useFocusEffect } from 'expo-router';
import React, { useCallback, useMemo, useState } from 'react';
import { Alert, FlatList, Keyboard, Platform, SafeAreaView, StatusBar, StyleSheet, Text, TextInput, TouchableOpacity, View } from 'react-native';

export default function JournalScreen() {
    const [note, setNote] = useState('');
    const [allNotes, setAllNotes] = useState<GratitudeNote[]>([]);
    const [currentDate, setCurrentDate] = useState(new Date());
    const [isPickerVisible, setIsPickerVisible] = useState(false);

    const loadNotes = async () => {
        const notes = await StorageService.getGratitudeNotes();
        setAllNotes(notes);
    };

    useFocusEffect(useCallback(() => {
        loadNotes();
    }, []));

    // Filter notes by current month/year
    const filteredNotes = useMemo(() => {
        const targetMonth = currentDate.getMonth();
        const targetYear = currentDate.getFullYear();

        return allNotes.filter(note => {
            const noteDate = new Date(note.date);
            return noteDate.getMonth() === targetMonth && noteDate.getFullYear() === targetYear;
        });
    }, [currentDate, allNotes]);

    const handleMonthChange = (direction: 'prev' | 'next') => {
        setCurrentDate(prevDate => {
            const newDate = new Date(prevDate);
            newDate.setDate(1);
            newDate.setMonth(newDate.getMonth() + (direction === 'prev' ? -1 : 1));
            return newDate;
        });
    };

    const handleDateSelect = (newDate: Date) => {
        setCurrentDate(newDate);
    };

    const handleSave = async () => {
        if (note.trim().length === 0) return;
        const newNote: GratitudeNote = {
            note: note.trim(),
            date: new Date().toISOString(),
        };
        await StorageService.saveGratitudeNote(newNote);
        setNote('');
        Keyboard.dismiss();
        await loadNotes();
    };

    const handleDelete = async (noteDate: string) => {
        Alert.alert(
            "Delete Note",
            "Are you sure you want to delete this gratitude note?",
            [
                { text: "Cancel", style: "cancel" },
                { 
                    text: "Delete", 
                    style: "destructive", 
                    onPress: async () => {
                        await StorageService.deleteGratitudeNote(noteDate);
                        await loadNotes();
                    }
                },
            ]
        );
    };

    const formattedDate = currentDate.toLocaleString('default', { month: 'long', year: 'numeric' });

    return (
        <SafeAreaView style={styles.container}>
            <StatusBar 
                barStyle="light-content" 
                backgroundColor="#121212" 
                translucent={false}
            />
            
            {/* Header Section */}
            <View style={styles.headerSection}>
                <Text style={styles.header}>Gratitude Journal</Text>
                <Text style={styles.prompt}>What are you grateful for today?</Text>
                
                <TextInput
                    style={styles.input}
                    multiline
                    placeholder="Write your thoughts here..."
                    placeholderTextColor="#666"
                    value={note}
                    onChangeText={setNote}
                />
                
                <TouchableOpacity style={styles.saveButton} onPress={handleSave}>
                    <Ionicons name="heart" size={20} color="#FFFFFF" style={styles.saveButtonIcon} />
                    <Text style={styles.saveButtonText}>Save Today's Note</Text>
                </TouchableOpacity>
            </View>

            {/* History Section with Month Navigation */}
            <View style={styles.historySection}>
                <View style={styles.historyHeader}>
                    <Text style={styles.historyTitle}>Past Reflections</Text>
                </View>

                <View style={styles.monthNavigator}>
                    <TouchableOpacity onPress={() => handleMonthChange('prev')} style={styles.arrowButton}>
                        <Ionicons name="chevron-back" size={24} color="#FF6D00" />
                    </TouchableOpacity>
                    <TouchableOpacity onPress={() => setIsPickerVisible(true)}>
                        <Text style={styles.monthText}>{formattedDate}</Text>
                    </TouchableOpacity>
                    <TouchableOpacity onPress={() => handleMonthChange('next')} style={styles.arrowButton}>
                        <Ionicons name="chevron-forward" size={24} color="#FF6D00" />
                    </TouchableOpacity>
                </View>

                {/* Notes List */}
                <FlatList
                    data={filteredNotes}
                    keyExtractor={(item) => item.date}
                    showsVerticalScrollIndicator={false}
                    contentContainerStyle={styles.listContent}
                    ListEmptyComponent={
                        <View style={styles.emptyContainer}>
                            <Ionicons name="book-outline" size={48} color="#444" />
                            <Text style={styles.emptyText}>
                                No reflections for {formattedDate}.
                            </Text>
                            <Text style={styles.emptySubtext}>
                                Start writing to capture your gratitude.
                            </Text>
                        </View>
                    }
                    renderItem={({ item }) => (
                        <View style={styles.noteCard}>
                            <View style={styles.noteHeader}>
                                <View style={styles.dateContainer}>
                                    <Ionicons name="calendar-outline" size={16} color="#A0A0A0" />
                                    <Text style={styles.noteDate}>
                                        {new Date(item.date).toLocaleDateString('en-US', {
                                            weekday: 'short',
                                            month: 'short',
                                            day: 'numeric',
                                            hour: '2-digit',
                                            minute: '2-digit'
                                        })}
                                    </Text>
                                </View>
                                <TouchableOpacity 
                                    style={styles.deleteButton}
                                    onPress={() => handleDelete(item.date)}
                                >
                                    <Ionicons name="trash-bin-outline" size={18} color="#888" />
                                </TouchableOpacity>
                            </View>
                            <Text style={styles.noteText} numberOfLines={5} ellipsizeMode="tail">
                                {item.note}
                            </Text>
                        </View>
                    )}
                />
            </View>

            <MonthYearPickerModal 
                visible={isPickerVisible}
                initialDate={currentDate}
                onClose={() => setIsPickerVisible(false)}
                onSelect={handleDateSelect}
            />
        </SafeAreaView>
    );
}

const styles = StyleSheet.create({
    container: { 
        flex: 1, 
        backgroundColor: '#121212',
        paddingTop: Platform.OS === 'android' ? (StatusBar.currentHeight || 0) : 0,
    },
    
    // Header section for writing new notes
    headerSection: {
        paddingHorizontal: 20,
        paddingVertical: 20,
        borderBottomWidth: 1,
        borderBottomColor: '#333',
    },
    
    header: { 
        fontSize: 28, 
        fontWeight: 'bold', 
        color: '#FFFFFF', 
        textAlign: 'center', 
        marginBottom: 8 
    },
    
    prompt: { 
        fontSize: 16, 
        color: '#A0A0A0', 
        textAlign: 'center', 
        marginBottom: 20 
    },
    
    input: {
        backgroundColor: '#1E1E1E',
        borderRadius: 12,
        padding: 15,
        color: '#FFFFFF',
        fontSize: 16,
        minHeight: 100,
        maxHeight: 120,
        textAlignVertical: 'top',
        borderWidth: 1,
        borderColor: '#333',
    },
    
    saveButton: { 
        flexDirection: 'row',
        backgroundColor: '#FF6D00', 
        padding: 15, 
        borderRadius: 12, 
        alignItems: 'center', 
        justifyContent: 'center',
        marginTop: 15,
        elevation: 4,
        shadowColor: '#FF6D00',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.3,
        shadowRadius: 4,
    },
    
    saveButtonIcon: {
        marginRight: 8,
    },
    
    saveButtonText: { 
        color: '#FFFFFF', 
        fontSize: 16, 
        fontWeight: 'bold' 
    },
    
    // History section
    historySection: {
        flex: 1,
        paddingTop: 15,
    },
    
    historyHeader: {
        paddingHorizontal: 20,
        marginBottom: 10,
    },
    
    historyTitle: { 
        fontSize: 22, 
        fontWeight: 'bold', 
        color: '#FFFFFF',
    },
    
    monthNavigator: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
        paddingHorizontal: 20,
        paddingVertical: 10,
        marginBottom: 15,
    },
    
    arrowButton: {
        padding: 8,
        borderRadius: 8,
    },
    
    monthText: {
        fontSize: 18,
        fontWeight: '600',
        color: '#FFFFFF',
        textDecorationLine: 'underline',
        textDecorationStyle: 'dotted',
    },
    
    listContent: {
        paddingHorizontal: 15,
        paddingBottom: 20,
    },
    
    noteCard: { 
        backgroundColor: '#1E1E1E', 
        borderRadius: 12, 
        padding: 16, 
        marginBottom: 12,
        borderWidth: 1,
        borderColor: '#2A2A2A',
        elevation: 2,
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 1 },
        shadowOpacity: 0.1,
        shadowRadius: 2,
    },
    
    noteHeader: { 
        flexDirection: 'row', 
        justifyContent: 'space-between', 
        alignItems: 'center', 
        marginBottom: 10 
    },
    
    dateContainer: {
        flexDirection: 'row',
        alignItems: 'center',
    },
    
    noteDate: { 
        color: '#A0A0A0', 
        fontSize: 13,
        marginLeft: 6,
    },
    
    deleteButton: { 
        padding: 6,
        borderRadius: 6,
    },
    
    noteText: { 
        color: '#E0E0E0', 
        fontSize: 15,
        lineHeight: 22,
    },
    
    emptyContainer: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
        paddingVertical: 60,
    },
    
    emptyText: { 
        color: '#A0A0A0', 
        fontSize: 16,
        textAlign: 'center',
        marginTop: 16,
        fontWeight: '500',
    },
    
    emptySubtext: {
        color: '#666',
        fontSize: 14,
        textAlign: 'center',
        marginTop: 8,
        fontStyle: 'italic',
    },
});

===============================================
File: app\(tabs)\library.tsx
===============================================

/*  
 * FILE: /app/(tabs)/library.tsx  
 * Updated to replace Bhairav Vigraha with Reddit community link
 * The Reddit section has an attractive, small yet tempting design to join the community
 * ================================================================= 
 */ 
import { STOTRAS, Stotra } from '@/data/stotras';
import { Link } from 'expo-router';
import React from 'react';
import { FlatList, Image, Linking, Platform, SafeAreaView, StatusBar, StyleSheet, Text, TouchableOpacity, View } from 'react-native';

export default function LibraryScreen() {
  const handleRedditPress = async () => {
    const url = 'https://www.reddit.com/r/TantraUncensored/';
    try {
      await Linking.openURL(url);
    } catch (error) {
      console.error('Failed to open Reddit link:', error);
    }
  };

  return (
    <SafeAreaView style={libStyles.container}>
      <StatusBar 
        barStyle="light-content"
        backgroundColor="#121212"
        translucent={false}
      />
            
      {/* Reddit Community Section */}
      <View style={libStyles.specialSection}>
        <TouchableOpacity style={libStyles.redditItem} onPress={handleRedditPress}>
          <View style={libStyles.redditHeader}>
            <Image 
              source={require('@/assets/images/reddit_logo.jpg')} 
              style={libStyles.redditLogo}
              resizeMode="contain"
            />
            <View style={libStyles.redditTextContainer}>
              <Text style={libStyles.redditTitle}>Join Our Community</Text>
              <Text style={libStyles.redditSubtitle}>r/TantraUncensored</Text>
            </View>
          </View>
          <Text style={libStyles.redditDescription}>
            Have doubts? Want to learn? Join fellow sadhaks to ask questions and share insights
          </Text>
          <View style={libStyles.redditCTA}>
            <Text style={libStyles.redditCTAText}>Tap to Join →</Text>
          </View>
        </TouchableOpacity>
      </View>
       
      <FlatList 
        data={STOTRAS}
        keyExtractor={(item) => item.id}
        contentContainerStyle={libStyles.listContentContainer}
        renderItem={({ item }: { item: Stotra }) => (
          <Link href={`/stotra/${item.id}`} asChild>
            <TouchableOpacity style={libStyles.listItem}>
              <Text style={libStyles.title}>{item.title}</Text>
            </TouchableOpacity>
          </Link>
        )}
       />
    </SafeAreaView>
  );
}

const libStyles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#121212',
    paddingTop: Platform.OS === 'android' ? StatusBar.currentHeight : 0,
  },
  
  // Special section for Reddit community
  specialSection: {
    paddingHorizontal: 16,
    paddingTop: 20,
    paddingBottom: 10,
  },
  
  redditItem: {
    backgroundColor: '#1A1A1B',
    padding: 16,
    borderRadius: 12,
    marginBottom: 10,
    borderWidth: 1,
    borderColor: '#FF4500',
    shadowColor: '#FF4500',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.3,
    shadowRadius: 4,
    elevation: 5,
  },
  
  redditHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8,
  },
  
  redditLogo: {
    width: 32,
    height: 32,
    marginRight: 12,
  },
  
  redditTextContainer: {
    flex: 1,
  },
  
  redditTitle: {
    fontSize: 16,
    color: '#FFFFFF',
    fontWeight: 'bold',
  },
  
  redditSubtitle: {
    fontSize: 14,
    color: '#FF4500',
    fontWeight: '600',
  },
  
  redditDescription: {
    fontSize: 12,
    color: '#CCCCCC',
    lineHeight: 16,
    marginBottom: 8,
  },
  
  redditCTA: {
    alignSelf: 'flex-end',
    backgroundColor: '#FF4500',
    paddingHorizontal: 12,
    paddingVertical: 4,
    borderRadius: 6,
  },
  
  redditCTAText: {
    fontSize: 12,
    color: '#FFFFFF',
    fontWeight: 'bold',
  },

  // List styles remain the same
  listContentContainer: {
    paddingTop: 20,
    paddingBottom: 40,
    paddingHorizontal: 16,
  },
  
  listItem: {
    backgroundColor: '#2C2C2C',
    padding: 25,
    marginVertical: 8,
    marginHorizontal: 0,
    borderRadius: 10,
    alignItems: 'center',
    minHeight: 60,
  },
  
  title: {
    fontSize: 18,
    color: '#FFFFFF',
    fontWeight: '600',
    textAlign: 'center',
  },
});

===============================================
File: app\(tabs)\vigraha.tsx
===============================================

import { Ionicons } from '@expo/vector-icons';
import React, { useEffect, useRef, useState } from 'react';
import {
  Animated,
  Dimensions,
  FlatList,
  Image,
  Platform,
  SafeAreaView,
  State,
  StatusBar,
  StyleSheet,
  Text,
  TouchableOpacity,
  View
} from 'react-native';

const { width: screenWidth, height: screenHeight } = Dimensions.get('window');

// Optimized dimensions for better visual balance
const ITEM_WIDTH = screenWidth * 0.65; // Slightly larger but not overwhelming
const ITEM_HEIGHT = ITEM_WIDTH * 1.2; // Better aspect ratio
const ITEM_SPACING = 20;

// Enhanced data with proper image paths and content
const images = [
  { 
    id: '1', 
    source: require('@/assets/images/Ganesha_Ji.jpeg'), 
    name: 'Ganesha Ji', 
    hindiName: 'विघ्नहर्ता गणेश जी', 
    description: 'The remover of obstacles and lord of new beginnings.' 
  },
  { 
    id: '2', 
    source: require('@/assets/images/Aghor_Ganapati_Ji.jpeg'), 
    name: 'Aghor Ganapati Ji', 
    hindiName: 'अघोर गणपति जी', 
    description: 'A fierce and powerful form of Lord Ganesha, protector from all evils.' 
  },
  { 
    id: '3', 
    source: require('@/assets/images/Kal_Bhairav.jpg'), 
    name: 'Kal Bhairav', 
    hindiName: 'श्री काल भैरव', 
    description: 'The fierce manifestation of Lord Shiva associated with annihilation.' 
  },
  { 
    id: '4', 
    source: require('@/assets/images/Batuka_Bhairva.jpeg'), 
    name: 'Batuka Bhairva', 
    hindiName: 'बटुक भैरव', 
    description: 'The gentle, child form of Lord Bhairava who protects his devotees.' 
  },
  { 
    id: '5', 
    source: require('@/assets/images/Bhairva_Ji.jpeg'), 
    name: 'Bhairva Ji', 
    hindiName: 'भैरव जी', 
    description: 'The divine guardian deity, a powerful form of Shiva.' 
  },
  { 
    id: '6', 
    source: require('@/assets/images/Batuka_Bhairav_meditative.jpg'), 
    name: 'Meditating Bhairav', 
    hindiName: 'ध्यानस्थ भैरव', 
    description: 'Lord Bhairava in a deep state of meditation, radiating peace.' 
  },
  { 
    id: '7', 
    source: require('@/assets/images/Panchmukhi_Hanuman_Ji.jpeg'), 
    name: 'Panchmukhi Hanuman', 
    hindiName: 'पंचमुखी हनुमान जी', 
    description: 'The five-faced form of Hanuman, protector from all directions.' 
  },
];

export default function VigrahaScreen() {
  const scrollX = useRef(new Animated.Value(0)).current;
  const flatListRef = useRef<FlatList | null>(null);
  const [currentIndex, setCurrentIndex] = useState(0);
  const [expandedIndex, setExpandedIndex] = useState(0);
  const [viewMode, setViewMode] = useState('gallery');
  const lastTap = useRef<number | null>(null);

  // Handle pan gesture for swiping down to close fullscreen
  const handlePanGesture = (event: any) => {
    const { translationY, velocityY, state } = event.nativeEvent;
    
    // If user swipes down with enough velocity or distance
    if (state === State.END && (translationY > 100 || velocityY > 1000)) {
      setViewMode('gallery');
    }
  };

  // Handle scroll to update current index
  const handleScroll = (event: { nativeEvent: { contentOffset: { x: number } } }) => {
    const contentOffset = event.nativeEvent.contentOffset.x;
    const index = Math.round(contentOffset / (ITEM_WIDTH + ITEM_SPACING));
    const clampedIndex = Math.max(0, Math.min(index, images.length - 1));
    setCurrentIndex(clampedIndex);
  };

  // Scroll to specific index
  const scrollToIndex = (index: number) => {
    if (flatListRef.current && index >= 0 && index < images.length) {
      flatListRef.current.scrollToOffset({
        offset: index * (ITEM_WIDTH + ITEM_SPACING),
        animated: true,
      });
    }
  };

  const handleImagePress = () => {
    setExpandedIndex(currentIndex);
    setViewMode('expanded');
  };

  const handleExitFullscreen = () => {
    setViewMode('gallery');
    setTimeout(() => {
      scrollToIndex(expandedIndex);
      setCurrentIndex(expandedIndex);
    }, 100);
  };

  // Handle double tap to exit full-screen mode
  const handleDoubleTap = () => {
    const now = Date.now();
    const DOUBLE_PRESS_DELAY = 300;

    if (lastTap.current && now - lastTap.current < DOUBLE_PRESS_DELAY) {
      handleExitFullscreen();
    } else {
      lastTap.current = now;
    }
  };

  // Initialize scroll position when returning to gallery
  useEffect(() => {
    if (viewMode === 'gallery' && flatListRef.current) {
      setTimeout(() => {
        scrollToIndex(expandedIndex);
      }, 50);
    }
  }, [viewMode, expandedIndex]);

  // Render expanded view
  if (viewMode === 'expanded') {
    const currentImage = images[expandedIndex];
    return (
      <SafeAreaView style={[styles.safeArea, { backgroundColor: 'black' }]}>
        <StatusBar barStyle="light-content" backgroundColor="#000" />
        
        {/* Close button */}
        <TouchableOpacity
          style={styles.closeButton}
          onPress={handleExitFullscreen}
          activeOpacity={0.7}
        >
          <Ionicons name="close" size={28} color="white" />
        </TouchableOpacity>

        <View style={styles.fullScreenContainer}>
          <TouchableOpacity
            style={styles.fullScreenImageContainer}
            onPress={handleDoubleTap}
            onLongPress={handleExitFullscreen}
            activeOpacity={1}
          >
            <Image 
              source={currentImage.source} 
              style={styles.fullScreenImage}
              resizeMode="contain"
            />
          </TouchableOpacity>
          
          <View style={styles.fullScreenTextContainer}>
            <Text style={styles.fullScreenName}>{currentImage.name}</Text>
            <Text style={styles.fullScreenHindiName}>{currentImage.hindiName}</Text>
            <Text style={styles.fullScreenDescription}>{currentImage.description}</Text>
          </View>
        </View>
      </SafeAreaView>
    );
  }

  // Render Gallery View
  return (
    <SafeAreaView style={styles.safeArea}>
      <StatusBar barStyle="light-content" backgroundColor="#1a1a1a" />
      <View style={styles.container}>
        
        {/* Main Gallery */}
        <View style={styles.galleryContainer}>
          <Animated.FlatList
            ref={flatListRef}
            data={images}
            keyExtractor={(item) => item.id}
            horizontal
            showsHorizontalScrollIndicator={false}
            snapToInterval={ITEM_WIDTH + ITEM_SPACING}
            snapToAlignment="start"
            decelerationRate="fast"
            contentContainerStyle={{
              paddingHorizontal: (screenWidth - ITEM_WIDTH) / 2 - ITEM_SPACING / 2,
            }}
            onScroll={Animated.event(
              [{ nativeEvent: { contentOffset: { x: scrollX } } }],
              {
                useNativeDriver: false,
                listener: handleScroll,
              }
            )}
            scrollEventThrottle={16}
            initialScrollIndex={currentIndex}
            getItemLayout={(data, index) => ({
              length: ITEM_WIDTH + ITEM_SPACING,
              offset: (ITEM_WIDTH + ITEM_SPACING) * index,
              index,
            })}
            renderItem={({ item, index }) => {
              const inputRange = [
                (index - 1) * (ITEM_WIDTH + ITEM_SPACING),
                index * (ITEM_WIDTH + ITEM_SPACING),
                (index + 1) * (ITEM_WIDTH + ITEM_SPACING),
              ];

              const scale = scrollX.interpolate({
                inputRange,
                outputRange: [0.75, 1.15, 0.75],
                extrapolate: 'clamp',
              });

              const opacity = scrollX.interpolate({
                inputRange,
                outputRange: [0.5, 1, 0.5],
                extrapolate: 'clamp',
              });

              const translateY = scrollX.interpolate({
                inputRange,
                outputRange: [30, 0, 30],
                extrapolate: 'clamp',
              });

              const glowOpacity = scrollX.interpolate({
                inputRange,
                outputRange: [0, 0.8, 0],
                extrapolate: 'clamp',
              });

              const isInFocus = index === currentIndex;

              return (
                <View style={styles.itemWrapper}>
                  {/* Divine Glow Effect */}
                  <Animated.View 
                    style={[
                      styles.glowEffect, 
                      { 
                        opacity: glowOpacity,
                        transform: [{ scale }] 
                      }
                    ]} 
                  />
                  
                  <TouchableOpacity
                    activeOpacity={0.8}
                    onPress={() => isInFocus && handleImagePress()}
                    style={styles.touchableContainer}
                  >
                    <Animated.View
                      style={[
                        styles.imageContainer,
                        {
                          transform: [{ scale }, { translateY }],
                          opacity,
                        },
                      ]}
                    >
                      <Image 
                        source={item.source} 
                        style={styles.image}
                        resizeMode="cover"
                      />
                    </Animated.View>
                  </TouchableOpacity>
                </View>
              );
            }}
          />
        </View>

        {/* Bottom Content */}
        <View style={styles.bottomContainer}>
          {/* Name Display */}
          <View style={styles.nameContainer}>
            <Text style={styles.nameText}>{images[currentIndex]?.name}</Text>
            <Text style={styles.hindiNameText}>{images[currentIndex]?.hindiName}</Text>
          </View>

          {/* Indicators */}
          <View style={styles.indicatorContainer}>
            {images.map((_, index) => (
              <Animated.View
                key={index}
                style={[
                  styles.indicator,
                  {
                    backgroundColor: index === currentIndex ? '#FFD700' : 'rgba(255,255,255,0.3)',
                    transform: [{ scale: index === currentIndex ? 1.3 : 1 }],
                  },
                ]}
              />
            ))}
          </View>

          {/* Instructions */}
          <View style={styles.instructionsContainer}>
            <Text style={styles.instructionText}>Tap focused image to expand</Text>
            <Text style={styles.instructionText}>Long press or double tap to return</Text>
          </View>
        </View>
      </View>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
    backgroundColor: '#1a1a1a',
  },
  container: {
    flex: 1,
    backgroundColor: '#1a1a1a',
  },
  galleryContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  itemWrapper: {
    width: ITEM_WIDTH + ITEM_SPACING,
    alignItems: 'center',
    justifyContent: 'center',
    position: 'relative',
  },
  touchableContainer: {
    alignItems: 'center',
    justifyContent: 'center',
  },
  imageContainer: {
    width: ITEM_WIDTH,
    height: ITEM_HEIGHT,
    borderRadius: 20,
    overflow: 'hidden',
    borderWidth: 2,
    borderColor: 'rgba(255, 215, 0, 0.6)',
    backgroundColor: '#333',
    shadowColor: '#FFD700',
    shadowOffset: { width: 0, height: 8 },
    shadowOpacity: 0.3,
    shadowRadius: 15,
    elevation: 10,
  },
  image: {
    width: '100%',
    height: '100%',
  },
  glowEffect: {
    position: 'absolute',
    width: ITEM_WIDTH + 10,
    height: ITEM_HEIGHT + 10,
    borderRadius: 25,
    backgroundColor: 'rgba(255, 215, 0, 0.3)',
    shadowColor: '#FFD700',
    shadowOffset: { width: 0, height: 0 },
    shadowOpacity: 1,
    shadowRadius: 25,
    elevation: 5,
  },
  bottomContainer: {
    paddingBottom: Platform.OS === 'ios' ? 40 : 30,
    paddingHorizontal: 20,
    backgroundColor: '#1a1a1a',
  },
  nameContainer: {
    alignItems: 'center',
    marginBottom: 20,
    paddingHorizontal: 20,
  },
  nameText: {
    color: '#FFD700',
    fontSize: 22,
    fontWeight: '700',
    textAlign: 'center',
    marginBottom: 4,
  },
  hindiNameText: {
    color: 'rgba(255, 215, 0, 0.8)',
    fontSize: 16,
    fontWeight: '500',
    textAlign: 'center',
  },
  indicatorContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 20,
  },
  indicator: {
    width: 8,
    height: 8,
    borderRadius: 4,
    marginHorizontal: 4,
  },
  instructionsContainer: {
    alignItems: 'center',
  },
  instructionText: {
    color: 'rgba(255,255,255,0.6)',
    fontSize: 12,
    textAlign: 'center',
    marginVertical: 1,
  },
  
  // Fullscreen Styles
  fullScreenContainer: {
    flex: 1,
    backgroundColor: 'black',
  },
  fullScreenImageContainer: {
    flex: 1,
    width: '100%',
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 10,
    paddingTop: 80,
    paddingBottom: 120, // More space for text at bottom
  },
  fullScreenImage: {
    width: '100%',
    height: '100%',
    maxWidth: screenWidth - 20,
    maxHeight: screenHeight * 0.65, // Reduced height to make room for text
  },
  fullScreenTextContainer: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    alignItems: 'center',
    backgroundColor: 'rgba(0,0,0,0.9)', // Darker background for better text visibility
    paddingVertical: 25,
    paddingHorizontal: 20,
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
  },
  fullScreenName: {
    color: '#FFFFFF',
    fontSize: 26,
    fontWeight: 'bold',
    textAlign: 'center',
    marginBottom: 8,
  },
  fullScreenHindiName: {
    color: '#FFD700',
    fontSize: 20,
    fontWeight: '600',
    textAlign: 'center',
    marginBottom: 12,
  },
  fullScreenDescription: {
    color: '#CCCCCC',
    fontSize: 15,
    textAlign: 'center',
    fontStyle: 'italic',
    lineHeight: 22,
  },
  closeButton: {
    position: 'absolute',
    top: Platform.OS === 'android' ? 50 : 60,
    right: 20,
    zIndex: 10,
    backgroundColor: 'rgba(0,0,0,0.5)',
    borderRadius: 20,
    padding: 10,
  },
});

===============================================
File: app\stotra\[id].tsx
===============================================

/*
 * =================================================================
 * FILE TO UPDATE: /app/stotra/[id].tsx
 * Optimized version with performance improvements and memoization
 * to fix the VirtualizedList warning
 * =================================================================
 */
import AudioPlayer from '@/components/AudioPlayer';
import RecitationLogger from '@/components/RecitationLogger';
import { STOTRAS, Stanza } from '@/data/stotras';
import { useSadhanaAudioPlayer } from '@/hooks/useAudioPlayer';
import { Stack, useFocusEffect, useLocalSearchParams } from 'expo-router';
import React, { memo, useCallback } from 'react';
import { FlatList, Platform, SafeAreaView, StatusBar, StyleSheet, Text, View } from 'react-native';

// PERFORMANCE FIX: Memoized StanzaItem component
const StanzaItem = memo(({ item }: { item: Stanza }) => (
  <View style={detailStyles.stanzaContainer}>
    <Text style={detailStyles.sanskritText}>{item.sanskrit}</Text>
    <Text style={detailStyles.transliterationText}>{item.transliteration}</Text>
    <Text style={detailStyles.translationText}>{item.translation}</Text>
  </View>
));

// PERFORMANCE FIX: Memoized Header component
const ListHeader = memo(({ 
  title, 
  player, 
  status 
}: { 
  title: string;
  player: any;
  status: any;
}) => (
  <>
    <Text style={detailStyles.title}>{title}</Text>
    <AudioPlayer player={player} status={status} />
  </>
));

export default function StotraDetailScreen() {
  const { id } = useLocalSearchParams<{ id: string }>();
  const stotra = STOTRAS.find((s) => s.id === id);

  // The hook is now called at the top level of the screen component
  const { player, status } = useSadhanaAudioPlayer(stotra?.audio || 'kal_bhairav.mp3');

  // PERFORMANCE FIX: Memoized renderItem function
  const renderItem = useCallback(({ item }: { item: Stanza }) => (
    <StanzaItem item={item} />
  ), []);

  // PERFORMANCE FIX: Memoized keyExtractor function
  const keyExtractor = useCallback((item: Stanza, index: number) => 
    `${stotra?.id || 'default'}-stanza-${index}`, [stotra?.id]);

  // PERFORMANCE FIX: Memoized header component - moved before early return
  const headerComponent = useCallback(() => {
    if (!stotra) return null;
    return (
      <ListHeader 
        title={stotra.title}
        player={player}
        status={status}
      />
    );
  }, [stotra, player, status]);

  // FIXED: Added proper error handling and null checks
  useFocusEffect(
    useCallback(() => {
      // This runs when the screen comes into focus
      return () => {
        // This cleanup function runs when the screen goes out of focus
        try {
          if (player && status?.playing) {
            // Check if player is still valid before calling pause
            if (typeof player.pause === 'function') {
              player.pause();
            }
          }
        } catch {
          // Silently handle the error - this is expected when the player is already released
          console.log('Audio player already released - this is normal when navigating away');
        }
      };
    }, [player, status?.playing]) // Added optional chaining for status
  );

  if (!stotra) {
    return (
      <SafeAreaView style={detailStyles.container}>
        <Text style={detailStyles.title}>Stotra not found</Text>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView style={detailStyles.container}>
      <StatusBar 
        barStyle="light-content" 
        backgroundColor="#121212" 
        translucent={false}
      />
      <Stack.Screen options={{ title: stotra.title }} />
      <FlatList
        data={stotra.stanzas}
        keyExtractor={keyExtractor}
        renderItem={renderItem}
        ListHeaderComponent={headerComponent}
        ListFooterComponent={<RecitationLogger stotra={stotra} />}
        contentContainerStyle={detailStyles.scrollContent}
        // PERFORMANCE OPTIMIZATIONS
        removeClippedSubviews={true}
        maxToRenderPerBatch={10}
        updateCellsBatchingPeriod={50}
        initialNumToRender={10}
        windowSize={10}
        // Disable nested scrolling optimizations that can cause issues
        nestedScrollEnabled={false}
      />
    </SafeAreaView>
  );
}

const detailStyles = StyleSheet.create({
  container: { 
    flex: 1, 
    backgroundColor: '#121212',
    paddingTop: Platform.OS === 'android' ? StatusBar.currentHeight : 0,
  },
  scrollContent: { paddingBottom: 40 },
  title: { fontSize: 32, fontWeight: 'bold', color: '#FFFFFF', textAlign: 'center', marginVertical: 20, paddingHorizontal: 10 },
  stanzaContainer: { backgroundColor: '#1E1E1E', marginHorizontal: 16, marginVertical: 8, padding: 20, borderRadius: 12 },
  sanskritText: { fontSize: 22, color: '#FFFFFF', lineHeight: 36, marginBottom: 15, textAlign: 'center' },
  transliterationText: { fontSize: 16, color: '#B0B0B0', fontStyle: 'italic', lineHeight: 26, marginBottom: 15, textAlign: 'center' },
  translationText: { fontSize: 16, color: '#E0E0E0', lineHeight: 24, textAlign: 'center' },
});


===============================================
File: assets\fonts\SpaceMono-Regular.ttf
===============================================

[Non-text file]




===============================================
File: components\AddGoalModal.tsx
===============================================

/*
 * =================================================================
 * NEW FILE: /components/AddGoalModal.tsx
 * A modal form for creating new spiritual or material goals.
 * =================================================================
 */
import { Goal, GoalType } from '@/services/StorageService';
import React, { useState } from 'react';
import { Modal, StyleSheet, Switch, Text, TextInput, TouchableOpacity, View } from 'react-native';

type AddGoalModalProps = {
    visible: boolean;
    onClose: () => void;
    onSave: (goal: Goal) => void;
};

export default function AddGoalModal({ visible, onClose, onSave }: AddGoalModalProps) {
    const [title, setTitle] = useState('');
    const [goalType, setGoalType] = useState<GoalType>('spiritual');

    const handleSave = () => {
        if (title.trim().length === 0) {
            Alert.alert("Title Required", "Please enter a title for your goal.");
            return;
        }
        const newGoal: Goal = {
            id: Date.now().toString(),
            title: title.trim(),
            type: goalType,
            isCompleted: false,
        };
        onSave(newGoal);
        setTitle('');
        onClose();
    };

    return (
        <Modal
            animationType="slide"
            transparent={true}
            visible={visible}
            onRequestClose={onClose}
        >
            <View style={styles.centeredView}>
                <View style={styles.modalView}>
                    <Text style={styles.modalTitle}>Set a New Saṅkalpa</Text>
                    <TextInput
                        style={styles.input}
                        placeholder="What is your intention?"
                        placeholderTextColor="#666"
                        value={title}
                        onChangeText={setTitle}
                    />
                    <View style={styles.switchContainer}>
                        <Text style={styles.switchLabel}>Material</Text>
                        <Switch
                            trackColor={{ false: "#767577", true: "#FF6D00" }}
                            thumbColor={goalType === 'spiritual' ? "#f4f3f4" : "#f4f3f4"}
                            onValueChange={() => setGoalType(prev => prev === 'spiritual' ? 'material' : 'spiritual')}
                            value={goalType === 'spiritual'}
                        />
                        <Text style={styles.switchLabel}>Spiritual</Text>
                    </View>
                    <View style={styles.buttonRow}>
                        <TouchableOpacity style={[styles.button, styles.buttonClose]} onPress={onClose}>
                            <Text style={styles.buttonText}>Cancel</Text>
                        </TouchableOpacity>
                        <TouchableOpacity style={[styles.button, styles.buttonSave]} onPress={handleSave}>
                            <Text style={styles.buttonText}>Save Goal</Text>
                        </TouchableOpacity>
                    </View>
                </View>
            </View>
        </Modal>
    );
}

const styles = StyleSheet.create({
    centeredView: { flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: 'rgba(0,0,0,0.6)' },
    modalView: { width: '90%', backgroundColor: '#1E1E1E', borderRadius: 20, padding: 25, alignItems: 'center' },
    modalTitle: { fontSize: 22, fontWeight: 'bold', color: '#FFFFFF', marginBottom: 20 },
    input: { backgroundColor: '#333', color: '#FFFFFF', width: '100%', borderRadius: 10, padding: 15, fontSize: 16, marginBottom: 20 },
    switchContainer: { flexDirection: 'row', alignItems: 'center', marginBottom: 30 },
    switchLabel: { color: '#FFFFFF', fontSize: 16, marginHorizontal: 10 },
    buttonRow: { flexDirection: 'row', justifyContent: 'space-between', width: '100%' },
    button: { borderRadius: 10, padding: 12, elevation: 2, flex: 1, marginHorizontal: 5 },
    buttonClose: { backgroundColor: '#555' },
    buttonSave: { backgroundColor: '#FF6D00' },
    buttonText: { color: 'white', fontWeight: 'bold', textAlign: 'center', fontSize: 16 },
});

===============================================
File: components\AudioPlayer.tsx
===============================================

/*
 * =================================================================
 * FILE TO UPDATE: /components/AudioPlayer.tsx
 * Using community slider for reliability
 * =================================================================
 */
import { Ionicons } from '@expo/vector-icons';
import Slider from '@react-native-community/slider';
import { AudioPlayer as PlayerInstance } from 'expo-audio';
import React, { useCallback, useState } from 'react';
import { ActivityIndicator, StyleSheet, Text, TouchableOpacity, View } from 'react-native';

type AudioPlayerProps = {
  player: PlayerInstance | null;
  status: any;
};

const formatTime = (millis: number | null) => {
    if (millis === null || isNaN(millis)) return '00:00';
    const totalSeconds = Math.floor(millis / 1000);
    const seconds = totalSeconds % 60;
    const minutes = Math.floor(totalSeconds / 60);
    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
};

export default function AudioPlayer({ player, status }: AudioPlayerProps) {
  const [wasPlayingBeforeSeek, setWasPlayingBeforeSeek] = useState(false);
  const [isChangingRate, setIsChangingRate] = useState(false);

  const togglePlayback = useCallback(() => {
    if (!player || isChangingRate) return;
    try {
      if (status?.playing) {
        player.pause();
      } else {
        player.play();
      }
    } catch (error) {
      console.log('Audio player operation failed - player may have been released');
    }
  }, [player, status?.playing, isChangingRate]);

  const changeRate = useCallback(async (rate: number) => {
    if (!player || isChangingRate) return;
    
    setIsChangingRate(true);
    const wasPlaying = status?.playing || false;
    
    try {
      if (wasPlaying) {
        await player.pause();
      }
      
      await new Promise(resolve => setTimeout(resolve, 50));
      await player.setPlaybackRate(rate);
      
      if (wasPlaying) {
        await new Promise(resolve => setTimeout(resolve, 100));
        await player.play();
      }
    } catch (error) {
      console.log('Failed to change playback rate:', error);
    } finally {
      setIsChangingRate(false);
    }
  }, [player, status?.playing, isChangingRate]);

  const handleSeekStart = useCallback(() => {
    if (!player) return;
    try {
      setWasPlayingBeforeSeek(status?.playing || false);
      if (status?.playing) {
        player.pause();
      }
    } catch (error) {
      console.log('Failed to pause for seeking');
    }
  }, [player, status?.playing]);

  const handleSeekComplete = useCallback(async (positionSeconds: number) => {
    if (!player) return;
    try {
      await player.seekTo(Math.max(0, positionSeconds));
      
      if (wasPlayingBeforeSeek) {
        setTimeout(async () => {
          try {
            await player.play();
          } catch (error) {
            console.log('Failed to resume playback after seek');
          }
        }, 150);
      }
    } catch (error) {
      console.log('Failed to seek');
    }
  }, [player, wasPlayingBeforeSeek]);

  const playbackRates = [1.0, 1.25, 1.5, 2.0];
  const isLoading = !status?.isLoaded;
  const isPlaying = status?.playing || false;
  
  // Use seconds for the community slider
  const positionSeconds = status?.currentTime || 0;
  const durationSeconds = status?.duration || 0;
  const playbackRate = player?.playbackRate ?? 1.0;

  const shouldShowSlider = durationSeconds && durationSeconds > 0;

  return (
    <View style={audioStyles.container}>
      <TouchableOpacity 
        style={[
          audioStyles.playButton,
          (isLoading || isChangingRate) && audioStyles.playButtonDisabled
        ]} 
        onPress={togglePlayback} 
        disabled={isLoading || isChangingRate}
      >
        {isLoading || isChangingRate ? (
          <ActivityIndicator size="large" color="#FFFFFF" />
        ) : (
          <Ionicons 
            name={isPlaying ? 'pause' : 'play'} 
            size={40} 
            color="white" 
          />
        )}
      </TouchableOpacity>

      <View style={audioStyles.progressContainer}>
        <Text style={audioStyles.timeText}>
          {formatTime(positionSeconds * 1000)}
        </Text>
        
        {shouldShowSlider ? (
          <Slider
            style={audioStyles.slider}
            minimumValue={0}
            maximumValue={durationSeconds}
            value={positionSeconds}
            onSlidingStart={handleSeekStart}
            onSlidingComplete={handleSeekComplete}
            minimumTrackTintColor="#FF6D00"
            maximumTrackTintColor="#555"
            thumbTintColor="#FF6D00"
            disabled={isLoading || isChangingRate}
          />
        ) : (
          <View style={audioStyles.slider} />
        )}
        
        <Text style={audioStyles.timeText}>
          {formatTime(durationSeconds * 1000)}
        </Text>
      </View>

      <View style={audioStyles.speedContainer}>
        {playbackRates.map((rate) => (
          <TouchableOpacity 
            key={rate} 
            onPress={() => changeRate(rate)} 
            style={[
              audioStyles.speedButton, 
              playbackRate === rate && audioStyles.speedButtonActive,
              isChangingRate && audioStyles.speedButtonDisabled
            ]}
            disabled={isChangingRate}
          >
            <Text 
              style={[
                audioStyles.speedButtonText, 
                playbackRate === rate && audioStyles.speedButtonTextActive,
                isChangingRate && audioStyles.speedButtonTextDisabled
              ]}
            >
              {rate}x
            </Text>
          </TouchableOpacity>
        ))}
      </View>
    </View>
  );
}

const audioStyles = StyleSheet.create({
  container: { 
    padding: 20, 
    backgroundColor: '#1E1E1E', 
    borderRadius: 15, 
    marginHorizontal: 10, 
    alignItems: 'center' 
  },
  playButton: { 
    backgroundColor: '#FF6D00', 
    width: 80, 
    height: 80, 
    borderRadius: 40, 
    alignItems: 'center', 
    justifyContent: 'center', 
    marginBottom: 20 
  },
  playButtonDisabled: {
    backgroundColor: '#FF6D00AA',
  },
  progressContainer: { 
    width: '100%', 
    flexDirection: 'row', 
    alignItems: 'center', 
    justifyContent: 'center', 
    marginBottom: 15 
  },
  slider: { 
    flex: 1, 
    marginHorizontal: 10,
    height: 40,
  },
  timeText: { 
    color: '#AAA', 
    fontSize: 12, 
    width: 45, 
    textAlign: 'center' 
  },
  speedContainer: { 
    flexDirection: 'row', 
    justifyContent: 'space-around', 
    width: '100%', 
    paddingHorizontal: 20,
  },
  speedButton: { 
    paddingVertical: 8, 
    paddingHorizontal: 16, 
    borderRadius: 20, 
    backgroundColor: '#333',
    marginHorizontal: 4,
  },
  speedButtonActive: { 
    backgroundColor: '#FF6D00' 
  },
  speedButtonDisabled: {
    backgroundColor: '#333333AA',
  },
  speedButtonText: { 
    color: '#FFF', 
    fontWeight: 'bold',
    fontSize: 14
  },
  speedButtonTextActive: { 
    color: '#FFF' 
  },
  speedButtonTextDisabled: {
    color: '#FFFFFF66',
  }
});

===============================================
File: components\CustomSlider.tsx
===============================================

import React, { useCallback, useEffect, useRef, useState } from 'react';
import { Animated, PanResponder, StyleSheet, View } from 'react-native';

interface CustomSliderProps {
  style?: object;
  minimumValue: number;
  maximumValue: number;
  value: number;
  onSlidingStart?: () => void;
  onValueChange?: (value: number) => void;
  onSlidingComplete: (value: number) => void;
  minimumTrackTintColor: string;
  maximumTrackTintColor: string;
  thumbTintColor: string;
  disabled?: boolean;
}

export default function CustomSlider({ 
  style, 
  minimumValue, 
  maximumValue, 
  value, 
  onSlidingStart, 
  onValueChange, 
  onSlidingComplete, 
  minimumTrackTintColor, 
  maximumTrackTintColor, 
  thumbTintColor, 
  disabled = false 
}: CustomSliderProps) {
  const [trackWidth, setTrackWidth] = useState(0);
  const [isDragging, setIsDragging] = useState(false);
  const thumbPosition = useRef(new Animated.Value(0)).current;

  const THUMB_SIZE = 24;
  const TRACK_HEIGHT = 4;

  // Calculate progress percentage
  const getProgressPercentage = (currentValue: number): number => {
    if (maximumValue === minimumValue) return 0;
    return Math.max(0, Math.min(1, (currentValue - minimumValue) / (maximumValue - minimumValue)));
  };

  // Convert percentage to position
  const percentageToPosition = (percentage: number): number => {
    const availableWidth = trackWidth - THUMB_SIZE;
    return Math.max(0, Math.min(percentage * availableWidth, availableWidth));
  };

  // Convert position to value
  const positionToValue = (position: number): number => {
    const availableWidth = trackWidth - THUMB_SIZE;
    if (availableWidth <= 0) return minimumValue;
    
    const percentage = Math.max(0, Math.min(1, position / availableWidth));
    return minimumValue + (percentage * (maximumValue - minimumValue));
  };

  // Update thumb position when value changes externally (only if not dragging)
  useEffect(() => {
    if (!isDragging && trackWidth > 0) {
      const percentage = getProgressPercentage(value);
      const newPosition = percentageToPosition(percentage);
      thumbPosition.setValue(newPosition);
    }
  }, [value, trackWidth, isDragging]);

  // FIXED: Use useCallback to prevent onLayout infinite loop
  const handleLayout = useCallback((event: any) => {
    const { width } = event.nativeEvent.layout;
    // Only update if width actually changed
    if (width !== trackWidth && width > 0) {
      setTrackWidth(width);
    }
  }, [trackWidth]);

  const panResponder = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder: () => !disabled && trackWidth > 0,
      onMoveShouldSetPanResponder: () => !disabled && trackWidth > 0,
      
      onPanResponderGrant: (evt) => {
        if (disabled || trackWidth <= 0) return;
        
        console.log('Slider: Starting drag');
        setIsDragging(true);
        onSlidingStart?.();
        
        // Calculate position from touch location
        const touchX = evt.nativeEvent.locationX - (THUMB_SIZE / 2);
        const availableWidth = trackWidth - THUMB_SIZE;
        const clampedPosition = Math.max(0, Math.min(touchX, availableWidth));
        
        thumbPosition.setValue(clampedPosition);
        
        const newValue = positionToValue(clampedPosition);
        console.log('Slider: New value on grant:', newValue);
        onValueChange?.(newValue);
      },
      
      onPanResponderMove: (evt, gestureState) => {
        if (disabled || trackWidth <= 0) return;
        
        // Calculate new position based on gesture
        const startTouchX = evt.nativeEvent.locationX - gestureState.dx - (THUMB_SIZE / 2);
        const currentTouchX = startTouchX + gestureState.dx;
        const availableWidth = trackWidth - THUMB_SIZE;
        const clampedPosition = Math.max(0, Math.min(currentTouchX, availableWidth));
        
        thumbPosition.setValue(clampedPosition);
        
        const newValue = positionToValue(clampedPosition);
        onValueChange?.(newValue);
      },
      
      onPanResponderRelease: (evt, gestureState) => {
        if (disabled || trackWidth <= 0) return;
        
        console.log('Slider: Ending drag');
        
        // Calculate final position
        const startTouchX = evt.nativeEvent.locationX - gestureState.dx - (THUMB_SIZE / 2);
        const finalTouchX = startTouchX + gestureState.dx;
        const availableWidth = trackWidth - THUMB_SIZE;
        const finalPosition = Math.max(0, Math.min(finalTouchX, availableWidth));
        
        thumbPosition.setValue(finalPosition);
        
        const finalValue = positionToValue(finalPosition);
        console.log('Slider: Final value:', finalValue);
        onSlidingComplete(finalValue);
        setIsDragging(false);
      },
      
      onPanResponderTerminate: () => {
        console.log('Slider: Drag terminated');
        setIsDragging(false);
      },
    })
  ).current;

  // Don't render if track is too small
  if (trackWidth <= THUMB_SIZE) {
    return (
      <View 
        style={[styles.container, style]} 
        onLayout={handleLayout}
      />
    );
  }

  const availableWidth = trackWidth - THUMB_SIZE;

  return (
    <View 
      style={[styles.container, style]} 
      onLayout={handleLayout}
    >
      {/* Touch area - separate from visual elements */}
      <View 
        style={[styles.touchArea, { width: trackWidth }]}
        {...panResponder.panHandlers}
      />
      
      {/* Visual elements */}
      <View style={styles.visualContainer}>
        {/* Background track */}
        <View 
          style={[
            styles.track, 
            { 
              backgroundColor: maximumTrackTintColor,
              height: TRACK_HEIGHT,
              width: trackWidth - THUMB_SIZE,
              left: THUMB_SIZE / 2,
            }
          ]} 
        />
        
        {/* Progress track */}
        <Animated.View 
          style={[
            styles.progressTrack, 
            { 
              backgroundColor: minimumTrackTintColor, 
              height: TRACK_HEIGHT,
              left: THUMB_SIZE / 2,
              width: thumbPosition.interpolate({
                inputRange: [0, availableWidth || 1],
                outputRange: [0, availableWidth || 1],
                extrapolate: 'clamp'
              })
            }
          ]} 
        />
        
        {/* Thumb */}
        <Animated.View 
          style={[
            styles.thumb, 
            { 
              backgroundColor: thumbTintColor,
              width: THUMB_SIZE,
              height: THUMB_SIZE,
              borderRadius: THUMB_SIZE / 2,
              transform: [{ 
                translateX: thumbPosition.interpolate({
                  inputRange: [0, availableWidth || 1],
                  outputRange: [0, availableWidth || 0],
                  extrapolate: 'clamp'
                })
              }] 
            }
          ]} 
        />
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { 
    height: 40, 
    justifyContent: 'center',
    position: 'relative',
  },
  touchArea: {
    position: 'absolute',
    top: 0,
    bottom: 0,
    left: 0,
    zIndex: 10, // Make sure it's on top
  },
  visualContainer: {
    position: 'absolute',
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    justifyContent: 'center',
    zIndex: 1,
  },
  track: { 
    position: 'absolute', 
    borderRadius: 2, 
    top: '50%',
    marginTop: -2,
  },
  progressTrack: { 
    position: 'absolute', 
    borderRadius: 2, 
    top: '50%',
    marginTop: -2,
  },
  thumb: { 
    position: 'absolute', 
    borderWidth: 3, 
    borderColor: 'white',
    top: '50%',
    marginTop: -12,
    elevation: 8,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.4,
    shadowRadius: 6,
    zIndex: 5,
  },
});

===============================================
File: components\JapaCounter.tsx
===============================================

import { StorageService } from '@/services/StorageService';
import { Ionicons } from '@expo/vector-icons';
import { Audio } from 'expo-av';
import * as Haptics from 'expo-haptics';
import React, { useEffect, useRef, useState } from 'react';
import { Alert, LayoutAnimation, Platform, StyleSheet, Text, TouchableOpacity, UIManager, View } from 'react-native';

if (Platform.OS === 'android' && UIManager.setLayoutAnimationEnabledExperimental) {
    UIManager.setLayoutAnimationEnabledExperimental(true);
}

type JapaCounterProps = { 
  onJapaSaved: () => void; 
  isCompact?: boolean; 
};

export default function JapaCounter({ onJapaSaved, isCompact = false }: JapaCounterProps) {
  const [count, setCount] = useState<number>(0);
  const [malas, setMalas] = useState<number>(0);
  const [isFeedbackEnabled, setIsFeedbackEnabled] = useState(true);
  const tickSound = useRef<Audio.Sound | null>(null);
  const [isLoggingMode, setIsLoggingMode] = useState(false);
  const [malasToLog, setMalasToLog] = useState(1);

  useEffect(() => {
    let isMounted = true;
    const loadSound = async () => {
      try {
        if (isMounted) {
          const { sound } = await Audio.Sound.createAsync(
            require('../assets/audio/Effect_Tick.mp3')
          );
          tickSound.current = sound;
        }
      } catch (error) {
        console.error("Failed to load tick sound:", error);
      }
    };
    loadSound();
    return () => {
      isMounted = false;
      tickSound.current?.unloadAsync();
    };
  }, []);

  const playFeedback = async () => {
    if (isFeedbackEnabled) {
      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
      try {
        await tickSound.current?.replayAsync();
      } catch (error) {
        console.error("Failed to play tick sound", error);
      }
    }
  };

  const handlePress = () => {
    playFeedback();
    if (count === 107) {
      setCount(0);
      setMalas(prevMalas => prevMalas + 1);
    } else {
      setCount(prevCount => prevCount + 1);
    }
  };

  const saveAndReset = async (malasToSave: number) => {
    if (malasToSave <= 0) return;
    const session = { malas: malasToSave, date: new Date().toISOString() };
    await StorageService.saveJapaSession(session);
    setCount(0);
    setMalas(0);
    onJapaSaved();
  };

  const handleSave = () => {
    if (malas > 0) {
      Alert.alert("Confirm Save", `This will save your completed ${malas} mālā(s) and reset the counter. Continue?`, [
        { text: "Cancel", style: "cancel" },
        { text: "Save", onPress: () => saveAndReset(malas) },
      ]);
    } else if (count > 0) {
      Alert.alert("Reset Progress?", "You have not completed a full mālā. Would you like to reset your current count to 0?", [
        { text: "Cancel", style: "cancel" },
        { text: "Reset", style: "destructive", onPress: () => { setCount(0); setMalas(0); } },
      ]);
    }
  };

  const handleLogMalaPress = () => {
    LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
    setIsLoggingMode(true);
  };

  const handleConfirmLog = () => {
    const totalMalasToLog = malas + malasToLog;
    Alert.alert(`Log ${malasToLog} Mālā(s)`, `This will save a total of ${totalMalasToLog} mālā(s) and reset the counter. Continue?`, [
        { text: "Cancel", style: "cancel" },
        { text: "Log Mālā", onPress: () => {
            saveAndReset(totalMalasToLog);
            LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
            setIsLoggingMode(false);
            setMalasToLog(1);
        }},
    ]);
  };

  const handleCancelLog = () => {
    LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
    setIsLoggingMode(false);
    setMalasToLog(1);
  };

  // Dynamic styles based on compact mode
  const containerStyle = isCompact ? styles.containerCompact : styles.containerExpanded;
  const buttonStyle = isCompact ? styles.mainButtonCompact : styles.mainButtonExpanded;
  const countTextStyle = isCompact ? styles.countTextCompact : styles.countTextExpanded;
  const malaCountStyle = isCompact ? styles.malaCountCompact : styles.malaCountExpanded;

  return (
    <View style={[styles.container, containerStyle]}>
      <TouchableOpacity 
        style={styles.feedbackToggle} 
        onPress={() => setIsFeedbackEnabled(!isFeedbackEnabled)}
      >
        <Ionicons name={isFeedbackEnabled ? "volume-high" : "volume-mute"} size={20} color="#888" />
      </TouchableOpacity>

      <Text style={[styles.malaCount, malaCountStyle]}>{malas} Mālā{malas !== 1 ? 's' : ''}</Text>
      
      <TouchableOpacity style={[styles.mainButton, buttonStyle]} onPress={handlePress} activeOpacity={0.7}>
        <Text style={[styles.countText, countTextStyle]}>{count}</Text>
      </TouchableOpacity>

      <View style={styles.buttonRow}>
        {!isLoggingMode ? (
          <>
            <TouchableOpacity style={styles.actionButton} onPress={handleSave}>
              <Text style={styles.actionButtonText}>Save & Reset</Text>
            </TouchableOpacity>
            <TouchableOpacity style={styles.actionButton} onPress={handleLogMalaPress}>
              <Text style={styles.actionButtonText}>Log Mālās</Text>
            </TouchableOpacity>
          </>
        ) : (
          <View style={styles.loggingContainer}>
            <TouchableOpacity onPress={handleCancelLog} style={styles.cancelButton}>
                <Ionicons name="close" size={20} color="#FF6B6B" />
            </TouchableOpacity>
            <View style={styles.stepper}>
                <TouchableOpacity onPress={() => setMalasToLog(c => Math.max(1, c - 1))} style={styles.stepperButton}>
                    <Ionicons name="remove" size={24} color="#FF6D00" />
                </TouchableOpacity>
                <Text style={styles.stepperCount}>{malasToLog}</Text>
                <TouchableOpacity onPress={() => setMalasToLog(c => c + 1)} style={styles.stepperButton}>
                    <Ionicons name="add" size={24} color="#FF6D00" />
                </TouchableOpacity>
            </View>
            <TouchableOpacity onPress={handleConfirmLog} style={styles.confirmButton}>
                <Ionicons name="checkmark" size={20} color="#81C784" />
            </TouchableOpacity>
          </View>
        )}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
    container: { 
      alignItems: 'center', 
      backgroundColor: '#1E1E1E', 
      borderRadius: 20, 
      position: 'relative',
      elevation: 8,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 4 },
      shadowOpacity: 0.3,
      shadowRadius: 8,
    },
    
    // Expanded mode (when history is collapsed)
    containerExpanded: {
      padding: 40,
      marginHorizontal: 20,
      marginVertical: 20,
    },
    
    // Compact mode (when history is expanded)
    containerCompact: {
      padding: 15,
      marginHorizontal: 15,
      marginVertical: 15,
    },
    
    feedbackToggle: { 
      position: 'absolute', 
      top: 12, 
      right: 12, 
      padding: 5, 
      zIndex: 1 
    },
    
    malaCount: { 
      fontWeight: '300', 
      color: '#E0E0E0', 
      marginBottom: 12, 
      marginTop: 8 
    },
    
    malaCountExpanded: {
      fontSize: 32,
      marginBottom: 20,
    },
    
    malaCountCompact: {
      fontSize: 24,
      marginBottom: 12,
    },
    
    mainButton: { 
      backgroundColor: '#FF6D00', 
      alignItems: 'center', 
      justifyContent: 'center', 
      borderWidth: 6, 
      borderColor: 'rgba(255, 255, 255, 0.15)', 
      elevation: 12,
      shadowColor: '#FF6D00',
      shadowOffset: { width: 0, height: 8 },
      shadowOpacity: 0.3,
      shadowRadius: 16,
    },
    
    // Expanded button (when history is collapsed)
    mainButtonExpanded: {
      width: 280,
      height: 280,
      borderRadius: 140, // Perfect circle
    },
    
    // Compact button (when history is expanded)  
    mainButtonCompact: {
      width: 180,
      height: 180,
      borderRadius: 90, // Perfect circle
    },
    
    countText: { 
      fontWeight: 'bold', 
      color: '#FFFFFF' 
    },
    
    countTextExpanded: {
      fontSize: 100,
      textShadowColor: 'rgba(0, 0, 0, 0.3)',
      textShadowOffset: { width: 2, height: 2 },
      textShadowRadius: 4,
    },
    
    countTextCompact: {
      fontSize: 72,
      textShadowColor: 'rgba(0, 0, 0, 0.3)',
      textShadowOffset: { width: 1, height: 1 },
      textShadowRadius: 2,
    },
    
    buttonRow: { 
      flexDirection: 'row', 
      justifyContent: 'space-around', 
      width: '100%', 
      marginTop: 30, 
      minHeight: 50 
    },
    
    actionButton: { 
      backgroundColor: '#333333', 
      paddingVertical: 12, 
      paddingHorizontal: 24, 
      borderRadius: 30, 
      alignItems: 'center', 
      justifyContent: 'center',
      elevation: 4,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: 0.2,
      shadowRadius: 4,
    },
    
    actionButtonText: { 
      color: '#FFFFFF', 
      fontSize: 15, 
      fontWeight: 'bold' 
    },
    
    // Compact logging styles
    loggingContainer: {
        flex: 1,
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'space-between',
        backgroundColor: '#333',
        borderRadius: 25,
        paddingHorizontal: 8,
    },
    stepper: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'center',
    },
    stepperButton: {
        padding: 8,
    },
    stepperCount: {
        fontSize: 20,
        fontWeight: 'bold',
        color: '#FFFFFF',
        marginHorizontal: 15,
        minWidth: 30,
        textAlign: 'center',
    },
    cancelButton: {
        padding: 8,
        borderRadius: 15,
    },
    confirmButton: {
        padding: 8,
        borderRadius: 15,
    },
});

===============================================
File: components\MonthYearPickerModal.tsx
===============================================

// FIXED: Smooth iOS-like Wheel Picker without flickering
// /components/MonthYearPickerModal.tsx

import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { Dimensions, Modal, NativeScrollEvent, NativeSyntheticEvent, ScrollView, StyleSheet, Text, TouchableOpacity, View } from 'react-native';

type MonthYearPickerProps = {
  visible: boolean;
  initialDate: Date;
  onClose: () => void;
  onSelect: (date: Date) => void;
};

const MONTHS = [
  'January', 'February', 'March', 'April', 'May', 'June', 
  'July', 'August', 'September', 'October', 'November', 'December'
];

const { height: screenHeight } = Dimensions.get('window');
const ITEM_HEIGHT = 50;
const VISIBLE_ITEMS = 5;
const WHEEL_HEIGHT = ITEM_HEIGHT * VISIBLE_ITEMS;
const PADDING_COUNT = Math.floor(VISIBLE_ITEMS / 2);

const getCurrentYearRange = () => {
  const currentYear = new Date().getFullYear();
  const startYear = currentYear - 15;
  const endYear = currentYear + 5;
  return Array.from({ length: endYear - startYear + 1 }, (_, i) => startYear + i);
};

// Optimized Wheel Picker Component
const WheelPicker = ({ 
  data, 
  selectedIndex, 
  onValueChange, 
  label 
}: {
  data: (string | number)[];
  selectedIndex: number;
  onValueChange: (index: number) => void;
  label: string;
}) => {
  const scrollViewRef = useRef<ScrollView>(null);
  const isScrollingRef = useRef(false);
  const lastSelectedIndexRef = useRef(selectedIndex);
  const scrollTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Memoize the padded data to prevent re-renders
  const paddedData = React.useMemo(() => [
    ...Array(PADDING_COUNT).fill(''),
    ...data,
    ...Array(PADDING_COUNT).fill('')
  ], [data]);

  // Initialize scroll position only once
  useEffect(() => {
    const timer = setTimeout(() => {
      if (scrollViewRef.current && selectedIndex >= 0) {
        const initialOffset = selectedIndex * ITEM_HEIGHT;
        scrollViewRef.current.scrollTo({
          y: initialOffset,
          animated: false,
        });
        lastSelectedIndexRef.current = selectedIndex;
      }
    }, 50);

    return () => clearTimeout(timer);
  }, []); // Only run on mount

  // Update scroll position when selectedIndex changes externally
  useEffect(() => {
    if (selectedIndex !== lastSelectedIndexRef.current && !isScrollingRef.current) {
      const timer = setTimeout(() => {
        if (scrollViewRef.current) {
          const offset = selectedIndex * ITEM_HEIGHT;
          scrollViewRef.current.scrollTo({
            y: offset,
            animated: true,
          });
          lastSelectedIndexRef.current = selectedIndex;
        }
      }, 50);

      return () => clearTimeout(timer);
    }
  }, [selectedIndex]);

  // Debounced value change handler
  const debouncedValueChange = useCallback((index: number) => {
    if (scrollTimeoutRef.current) {
      clearTimeout(scrollTimeoutRef.current);
    }
    
    scrollTimeoutRef.current = setTimeout(() => {
      if (index !== lastSelectedIndexRef.current && index >= 0 && index < data.length) {
        lastSelectedIndexRef.current = index;
        onValueChange(index);
      }
    }, 50);
  }, [data.length, onValueChange]);

  const handleScrollBeginDrag = useCallback(() => {
    isScrollingRef.current = true;
    if (scrollTimeoutRef.current) {
      clearTimeout(scrollTimeoutRef.current);
    }
  }, []);

  const handleMomentumScrollEnd = useCallback((event: NativeSyntheticEvent<NativeScrollEvent>) => {
    const offsetY = event.nativeEvent.contentOffset.y;
    const index = Math.round(offsetY / ITEM_HEIGHT);
    const clampedIndex = Math.max(0, Math.min(index, data.length - 1));
    
    // Ensure perfect alignment
    const snapOffset = clampedIndex * ITEM_HEIGHT;
    if (Math.abs(offsetY - snapOffset) > 1) {
      scrollViewRef.current?.scrollTo({
        y: snapOffset,
        animated: true,
      });
    }
    
    isScrollingRef.current = false;
    debouncedValueChange(clampedIndex);
  }, [data.length, debouncedValueChange]);

  const handleScrollEndDrag = useCallback((event: NativeSyntheticEvent<NativeScrollEvent>) => {
    const offsetY = event.nativeEvent.contentOffset.y;
    const index = Math.round(offsetY / ITEM_HEIGHT);
    const clampedIndex = Math.max(0, Math.min(index, data.length - 1));
    
    // Snap to the nearest item
    const snapOffset = clampedIndex * ITEM_HEIGHT;
    scrollViewRef.current?.scrollTo({
      y: snapOffset,
      animated: true,
    });
    
    debouncedValueChange(clampedIndex);
  }, [data.length, debouncedValueChange]);

  // Render items with memoization
  const renderItems = useMemo(() => {
    return paddedData.map((item, index) => {
      if (item === '') {
        return <View key={`empty-${index}`} style={styles.wheelItem} />;
      }
      
      const actualIndex = index - PADDING_COUNT;
      const isSelected = actualIndex === selectedIndex;
      const distance = Math.abs(actualIndex - selectedIndex);
      
      // Calculate opacity and scale based on distance from center
      let opacity = 1;
      let scale = 1;
      
      if (distance === 1) {
        opacity = 0.6;
        scale = 0.9;
      } else if (distance === 2) {
        opacity = 0.3;
        scale = 0.8;
      } else if (distance > 2) {
        opacity = 0.1;
        scale = 0.7;
      }

      return (
        <View
          key={`${item}-${actualIndex}`}
          style={[
            styles.wheelItem,
            {
              opacity,
              transform: [{ scale }],
            }
          ]}
        >
          <Text style={[
            styles.wheelItemText,
            isSelected && styles.wheelItemTextSelected
          ]}>
            {item}
          </Text>
        </View>
      );
    });
  }, [paddedData, selectedIndex]);

  return (
    <View style={styles.wheelSection}>
      <Text style={styles.wheelLabel}>{label}</Text>
      <View style={styles.wheelContainer}>
        {/* Selection indicator overlay */}
        <View style={styles.selectionIndicator} />
        
        <ScrollView 
          ref={scrollViewRef}
          style={styles.wheel}
          showsVerticalScrollIndicator={false}
          snapToInterval={ITEM_HEIGHT}
          snapToAlignment="start"
          decelerationRate="fast"
          onScrollBeginDrag={handleScrollBeginDrag}
          onScrollEndDrag={handleScrollEndDrag}
          onMomentumScrollEnd={handleMomentumScrollEnd}
          scrollEventThrottle={32} // Higher value for smoother performance
          bounces={false}
          overScrollMode="never"
          contentContainerStyle={styles.scrollContent}
        >
          {renderItems}
        </ScrollView>
      </View>
    </View>
  );
};

export default function MonthYearPickerModal({ visible, initialDate, onClose, onSelect }: MonthYearPickerProps) {
  const [selectedMonthIndex, setSelectedMonthIndex] = useState(initialDate.getMonth());
  const [selectedYearIndex, setSelectedYearIndex] = useState(0);
  
  const years = useMemo(() => getCurrentYearRange(), []);
  
  // Initialize year index
  useEffect(() => {
    if (visible) {
      const monthIndex = initialDate.getMonth();
      const yearIndex = years.findIndex(year => year === initialDate.getFullYear());
      
      setSelectedMonthIndex(monthIndex);
      if (yearIndex !== -1) {
        setSelectedYearIndex(yearIndex);
      }
    }
  }, [visible, initialDate, years]);

  const handleConfirm = useCallback(() => {
    const selectedYear = years[selectedYearIndex];
    const newDate = new Date(selectedYear, selectedMonthIndex, 1);
    onSelect(newDate);
    onClose();
  }, [years, selectedYearIndex, selectedMonthIndex, onSelect, onClose]);

  const handleCancel = useCallback(() => {
    const monthIndex = initialDate.getMonth();
    const yearIndex = years.findIndex(year => year === initialDate.getFullYear());
    
    setSelectedMonthIndex(monthIndex);
    if (yearIndex !== -1) {
      setSelectedYearIndex(yearIndex);
    }
    onClose();
  }, [initialDate, years, onClose]);

  return (
    <Modal
      animationType="slide"
      transparent={true}
      visible={visible}
      onRequestClose={handleCancel}
    >
      <View style={styles.overlay}>
        <View style={styles.modalContainer}>
          <View style={styles.header}>
            <Text style={styles.title}>Select Month & Year</Text>
            <Text style={styles.selectedDisplay}>
              {MONTHS[selectedMonthIndex]} {years[selectedYearIndex]}
            </Text>
          </View>
          
          <View style={styles.pickersContainer}>
            <WheelPicker
              data={MONTHS}
              selectedIndex={selectedMonthIndex}
              onValueChange={setSelectedMonthIndex}
              label="Month"
            />
            
            <WheelPicker
              data={years}
              selectedIndex={selectedYearIndex}
              onValueChange={setSelectedYearIndex}
              label="Year"
            />
          </View>

          <View style={styles.buttonContainer}>
            <TouchableOpacity 
              style={[styles.button, styles.cancelButton]} 
              onPress={handleCancel}
              activeOpacity={0.7}
            >
              <Text style={styles.cancelButtonText}>Cancel</Text>
            </TouchableOpacity>
            
            <TouchableOpacity 
              style={[styles.button, styles.confirmButton]} 
              onPress={handleConfirm}
              activeOpacity={0.7}
            >
              <Text style={styles.confirmButtonText}>Confirm</Text>
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );
}

const styles = StyleSheet.create({
  overlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.6)',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  modalContainer: {
    backgroundColor: '#1E1E1E',
    borderRadius: 20,
    width: '100%',
    maxWidth: 400,
    elevation: 10,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 10 },
    shadowOpacity: 0.3,
    shadowRadius: 20,
  },
  header: {
    paddingVertical: 25,
    paddingHorizontal: 20,
    borderBottomWidth: 1,
    borderBottomColor: '#333',
    alignItems: 'center',
  },
  title: {
    fontSize: 22,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginBottom: 8,
  },
  selectedDisplay: {
    fontSize: 18,
    color: '#FF6D00',
    fontWeight: '600',
  },
  pickersContainer: {
    flexDirection: 'row',
    paddingVertical: 20,
    paddingHorizontal: 10,
    gap: 10,
  },
  wheelSection: {
    flex: 1,
    alignItems: 'center',
  },
  wheelLabel: {
    fontSize: 16,
    fontWeight: '600',
    color: '#CCCCCC',
    marginBottom: 12,
    textAlign: 'center',
  },
  wheelContainer: {
    position: 'relative',
    height: WHEEL_HEIGHT,
    width: '100%',
  },
  wheel: {
    height: WHEEL_HEIGHT,
    backgroundColor: 'transparent',
  },
  scrollContent: {
    paddingVertical: 0,
  },
  selectionIndicator: {
    position: 'absolute',
    top: ITEM_HEIGHT * 2,
    left: 10,
    right: 10,
    height: ITEM_HEIGHT,
    borderRadius: 8,
    backgroundColor: 'rgba(255, 109, 0, 0.1)',
    borderWidth: 1,
    borderColor: 'rgba(255, 109, 0, 0.3)',
    zIndex: 1,
    pointerEvents: 'none',
  },
  wheelItem: {
    height: ITEM_HEIGHT,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 16,
  },
  wheelItemText: {
    fontSize: 18,
    color: '#CCCCCC',
    fontWeight: '500',
    textAlign: 'center',
  },
  wheelItemTextSelected: {
    color: '#FF6D00',
    fontWeight: 'bold',
    fontSize: 19,
  },
  buttonContainer: {
    flexDirection: 'row',
    padding: 20,
    paddingTop: 10,
    gap: 15,
  },
  button: {
    flex: 1,
    paddingVertical: 14,
    borderRadius: 12,
    alignItems: 'center',
    justifyContent: 'center',
  },
  cancelButton: {
    backgroundColor: '#404040',
    borderWidth: 1,
    borderColor: '#555',
  },
  confirmButton: {
    backgroundColor: '#FF6D00',
    elevation: 3,
    shadowColor: '#FF6D00',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
  },
  cancelButtonText: {
    color: '#CCCCCC',
    fontSize: 16,
    fontWeight: '600',
  },
  confirmButtonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
});

===============================================
File: components\RecitationLogger.tsx
===============================================


/*
 * =================================================================
 * NEW FILE: /components/RecitationLogger.tsx
 * This component handles logging recitations.
 * =================================================================
 */
import { Stotra } from '@/data/stotras';
import { StorageService } from '@/services/StorageService';
import { Ionicons } from '@expo/vector-icons';
import React, { useState } from 'react';
import { Alert, StyleSheet, Text, TouchableOpacity, View } from 'react-native';

type RecitationLoggerProps = {
    stotra: Stotra;
};

export default function RecitationLogger({ stotra }: RecitationLoggerProps) {
    const [count, setCount] = useState(1);

    const handleLogRecitation = () => {
        Alert.alert(
            "Log Recitation",
            `Confirm logging ${count} recitation(s) of "${stotra.title}"?`,
            [
                { text: "Cancel", style: "cancel" },
                {
                    text: "Log",
                    onPress: async () => {
                        const log = {
                            stotraId: stotra.id,
                            stotraTitle: stotra.title,
                            count: count,
                            date: new Date().toISOString(),
                        };
                        await StorageService.saveRecitationLog(log);
                        Alert.alert("Success", "Recitation logged successfully!");
                    },
                },
            ]
        );
    };

    return (
        <View style={loggerStyles.container}>
            <Text style={loggerStyles.title}>Log Your Recitation</Text>
            <View style={loggerStyles.controls}>
                <TouchableOpacity onPress={() => setCount(c => Math.max(1, c - 1))} style={loggerStyles.button}>
                    <Ionicons name="remove" size={24} color="#FF6D00" />
                </TouchableOpacity>
                <Text style={loggerStyles.count}>{count}</Text>
                <TouchableOpacity onPress={() => setCount(c => c + 1)} style={loggerStyles.button}>
                    <Ionicons name="add" size={24} color="#FF6D00" />
                </TouchableOpacity>
            </View>
            <TouchableOpacity style={loggerStyles.logButton} onPress={handleLogRecitation}>
                <Text style={loggerStyles.logButtonText}>Log {count} Recitation{count > 1 ? 's' : ''}</Text>
            </TouchableOpacity>
        </View>
    );
}

const loggerStyles = StyleSheet.create({
    container: { backgroundColor: '#1E1E1E', marginHorizontal: 16, marginTop: 20, padding: 20, borderRadius: 12, alignItems: 'center' },
    title: { fontSize: 18, fontWeight: 'bold', color: '#FFFFFF', marginBottom: 15 },
    controls: { flexDirection: 'row', alignItems: 'center', marginBottom: 20 },
    button: { backgroundColor: '#333', padding: 10, borderRadius: 20 },
    count: { fontSize: 24, fontWeight: 'bold', color: '#FFFFFF', marginHorizontal: 20 },
    logButton: { backgroundColor: '#FF6D00', paddingVertical: 12, paddingHorizontal: 30, borderRadius: 25 },
    logButtonText: { color: '#FFFFFF', fontSize: 16, fontWeight: 'bold' },
});


===============================================
File: data\stotras.ts
===============================================

/*
 * =================================================================
 * FILE TO UPDATE: /data/stotras.ts
 * This is the complete, unabridged code with all stanzas.
 * =================================================================
 */
export type Stanza = {
  sanskrit: string;
  transliteration: string;
  translation: string;
};

export type Stotra = {
  id: string;
  title: string;
  audio: 'kal_bhairav.mp3' | 'bhairava_stotra.mp3' | 'hanuman_chalisa.mp3' | 'Ashtottara_bhairav.mp3' | 'Bhairav_tandav.mp3';
  stanzas: Stanza[];
};

export const STOTRAS: Stotra[] = [
  {
    id: '1',
    title: 'Kāla Bhairava Aṣṭakam',
    audio: 'kal_bhairav.mp3',
    stanzas: [
        {
            sanskrit: `देवराजसेव्यमानपावनांघ्रिपङ्कजं
व्यालयज्ञसूत्रमिन्दुशेखरं कृपाकरम् ।
नारदादियोगिवृन्दवन्दितं दिगंबरं
काशिकापुराधिनाथकालभैरवं भजे ॥१॥`,
            transliteration: `Deva-Raaja-Sevyamaana-Paavana-Angghri-Pankajam
Vyaala-Yajnya-Suutram-Indu-Shekharam Krpaakaram |
Naarada-[A]adi-Yogi-Vrnda-Vanditam Digambaram
Kaashikaa-Pura-Adhinaatha-Kaalabhairavam Bhaje ||1||`,
            translation: `Salutations to Lord Kalabhairava, the supreme lord of Kashi, whose lotus feet are revered by Lord Indra; who has a snake as his sacrificial thread, a moon on his head and is very compassionate; who is praised by Narada and other yogis; and who is a Digambara, wearing the sky as his dress.`
        },
        {
            sanskrit: `भानुकोटिभास्वरं भवाब्धितारकं परं
नीलकण्ठमीप्सितार्थदायकं त्रिलोचनम् ।
कालकालमंबुजाक्षमक्षशूलमक्षरं
काशिकापुराधिनाथकालभैरवं भजे ॥२॥`,
            transliteration: `Bhaanu-Kotti-Bhaasvaram Bhavaabdhi-Taarakam Param
Niila-Kannttham-Iipsita-Artha-Daayakam Trilocanam |
Kaala-Kaalam-Ambuja-Akssam-Akssa-Shuulam-Akssaram
Kaashikaa-Pura-Adhinaatha-Kaalabhairavam Bhaje ||2||`,
            translation: `Salutations to Lord Kalabhairava, who has the brilliance of a million suns, who saves devotees from the cycle of rebirths; who has a blue throat, who grants our desires, and who has three eyes; who is death unto death itself and whose eyes look like a lotus; whose trident supports the world and who is immortal.`
        },
        {
            sanskrit: `शूलटङ्कपाशदण्डपाणिमादिकारणं
श्यामकायमादिदेवमक्षरं निरामयम् ।
भीमविक्रमं प्रभुं विचित्रताण्डवप्रियं
काशिकापुराधिनाथकालभैरवं भजे ॥३॥`,
            transliteration: `Shuula-Tanka-Paasha-Danndda-Paannim-Aadi-Kaarannam
Shyaama-Kaayam-Aadi-Devam-Akssaram Nir-Aamayam |
Bhiimavikramam Prabhum Vichitra-Taannddava-Priyam
Kaashikaa-Pura-Adhinaatha-Kaalabhairavam Bhaje ||3||`,
            translation: `Salutations to Lord Kalabhairava, who holds the trident, mattock, noose, and club in his hands; whose body is dark, who is the primordial Lord, who is immortal, and free from the diseases of the world; who is immensely mighty and who loves the wonderful tandava dance.`
        },
        {
            sanskrit: `भुक्तिमुक्तिदायकं प्रशस्तचारुविग्रहं
भक्तवत्सलं स्थितं समस्तलोकविग्रहम् ।
विनिक्वणन्मनोज्ञहेमकिङ्किणीलसत्कटिं
काशिकापुराधिनाथकालभैरवं भजे ॥४॥`,
            transliteration: `Bhukti-Mukti-Daayakam Prashasta-Caaru-Vigraham
Bhakta-Vatsalam Sthitam Samasta-Loka-Vigraham |
Vi-Nikvannan-Manojnya-Hema-Kinkinnii-Lasat-Kattim
Kaashikaa-Pura-Adhinaatha-Kaalabhairavam Bhaje ||4||`,
            translation: `Salutations to Lord Kalabhairava, the one who bestows both desires and salvation, who has a pleasing appearance; who is loving to his devotees, who is stable as the god of all the worlds; who wears a golden belt around his waist with bells that make a melodious sound when he moves.`
        },
        {
            sanskrit: `धर्मसेतुपालकं त्वधर्ममार्गनाशकं
कर्मपाशमोचकं सुशर्मदायकं विभुम् ।
स्वर्णवर्णशेषपाशशोभिताङ्गमण्डलं
काशिकापुराधिनाथकालभैरवं भजे ॥५॥`,
            transliteration: `Dharma-Setu-Paalakam Tva-Adharma-Maarga-Naashakam Karma-Paasha-Mocakam Su-Sharma-Daayakam Vibhum |
Svarnna-Varnna-Shessa-Paasha-Shobhitaangga-Mannddalam
Kaashikaa-Pura-Adhinaatha-Kaalabhairavam Bhaje ||5||`,
            translation: `Salutations to Lord Kalabhairava, who ensures that dharma (righteousness) prevails, who destroys the path of adharma (unrighteousness); who saves us from the bonds of karma, thereby freeing our soul; and who has golden-hued snakes entwined around his body.`
        },
        {
            sanskrit: `रत्नपादुकाप्रभाभिरामपादयुग्मकं
नित्यमद्वितीयमिष्टदैवतं निरंजनम् ।
मृत्युदर्पनाशनं करालदंष्ट्रमोक्षणं
काशिकापुराधिनाथकालभैरवं भजे ॥६॥`,
            transliteration: `Ratna-Paadukaa-Prabhaabhi-Raama-Paada-Yugmakam
Nityam-Advitiiyam-Isstta-Daivatam Niramjanam |
Mrtyu-Darpa-Naashanam Karaala-Damssttra-Mokssannam
Kaashikaa-Pura-Adhinaatha-Kaalabhairavam Bhaje ||6||`,
            translation: `Salutations to Lord Kalabhairava, whose feet are adorned with two golden sandals with gems; who is the eternal, non-dual Ishta devata (god who grants our desires); who destroys the pride of Yama (God of Death); whose terrible teeth liberate us.`
        },
        {
            sanskrit: `अट्टहासभिन्नपद्मजाण्डकोशसंततिं
दृष्टिपातनष्टपापजालमुग्रशासनम् ।
अष्टसिद्धिदायकं कपालमालिकाधरं
काशिकापुराधिनाथकालभैरवं भजे ॥७॥`,
            transliteration: `Atttta-Haasa-Bhinna-Padmaja-Anndda-Kosha-Samtatim
Drsstti-Paata-Nasstta-Paapa-Jaalam-Ugra-Shaasanam |
Asstta-Siddhi-Daayakam Kapaala-Maalikaa-Dharam
Kaashikaa-Pura-Adhinaatha-Kaalabhairavam Bhaje ||7||`,
            translation: `Salutations to Lord Kalabhairava, whose loud roar destroys the sheaths of creations (meaning the delusions of our mind) of the lotus-born Brahma; whose very glance is enough to destroy all our sins; who gives us the eight siddhis (accomplishments); and who wears a garland of skulls.`
        },
        {
            sanskrit: `भूतसंघनायकं विशालकीर्तिदायकं
काशिवासलोकपुण्यपापशोधकं विभुम् ।
नीतिमार्गकोविदं पुरातनं जगत्पतिं
काशिकापुराधिनाथकालभैरवं भजे ॥८॥`,
            transliteration: `Bhuuta-Samgha-Naayakam Vishaala-Kiirti-Daayakam
Kaashi-Vaasa-Loka-Punnya-Paapa-Shodhakam Vibhum |
Niiti-Maarga-Kovidam Puraatanam Jagatpatim
Kaashikaapuraadhinaathakaalabhairavam Bhaje ||8||`,
            translation: `Salutations to Lord Kalabhairava, who is the leader of ghosts and goblins, who bestows glory; who frees the people of Kashi from their sinful and righteous deeds; who guides us on the path of righteousness, who is the most ancient (eternal) lord of the universe.`
        },
        {
            sanskrit: `कालभैरवाष्टकं पठंति ये मनोहरं
ज्ञानमुक्तिसाधनं विचित्रपुण्यवर्धनम् ।
शोकमोहदैन्यलोभकोपतापनाशनं
प्रयान्ति कालभैरवांघ्रिसन्निधिं नरा ध्रुवम् ॥९॥`,
            transliteration: `Kaalabhairavaassttakam Patthamti Ye Manoharam
Jnyaana-Mukti-Saadhanam Vicitra-Punnya-Vardhanam |
Shoka-Moha-Dainya-Lobha-Kopa-Taapa-Naashanam
Prayaanti Kaalabhairava-Amghri-Sannidhim Naraa Dhruvam ||9||`,
            translation: `Those who read these eight verses of the Kalabhairava Ashtakam, which is beautiful, which is a source of knowledge and liberation, which increases the various forms of righteousness in a person, which destroys grief, attachment, poverty, greed, anger, and heat – will attain (after death) the feet of Lord Kalabhairava.`
        }
    ]
  },
  {
    id: '2',
    title: 'Abhinavagupta’s Bhairava Stotra',
    audio: 'bhairava_stotra.mp3',
    stanzas: [
        {
            sanskrit: `व्याप्तचराचरभावविशेषं
चिन्मयमेकमनन्तमनादिम् ।
भैरवनाथमनाथशरण्यं
तन्मयचित्ततया हृदि वन्दे ॥१॥`,
            transliteration: `vyāpta-carācara-bhāva-viśeṣaṁ
cinmayam-ekam-anantam-anādim /
bhairava-nātham-anātha-śaraṇyaṁ
tan-maya-citta-tayā hṛdi vande //1//`,
            translation: `I, Abhinavagupta, with one pointed devotion, am praying to that supreme all-pervading Lord Śiva, who is himself present in each and everything that exists, and who through realization reveals himself as the one limitless Bhairavanātha the protector of the helpless.`
        },
        {
            sanskrit: `त्वन्मयमेतदशेषमिदानीं
भाति मम त्वदनुग्रहशक्त्या ।
त्वं च महेश! सदैव ममात्मा
स्वात्ममयं मम तेन समस्तम्॥२॥`,
            transliteration: `tvanmayam-etad-aśeṣam-idānīṁ
bhāti mama tvad-anugraha-śaktyā /
tvaṁ ca maheśa! sadaiva mamātmā
svātmam-ayaṁ mama tena samastam //2//`,
            translation: `By the energy of your grace it has been revealed to me that this vibrating universe is your own existence. Thus, O Lord Śiva, this realization has come to me that you are my own soul and as such this universe is my own expression and existence.`
        },
        {
            sanskrit: `स्वात्मनि विश्वगते त्वयि नाथे
तेन न संसृतिभीतिः कथाऽस्ति ।
सत्स्वपि दुर्धरदुःखविमोह-
त्रासविधायिषु कर्मगणेषु ॥३॥`,
            transliteration: `svātmani viśvagate tvayi nāthe
tena na saṁsṛti-bhītiḥ kathā’sti /
satsvapi durdhara-duḥkha-vimoha-
trāsa-vidhāyiṣu karma-gaṇeṣu //3//`,
            translation: `O possessor of everything, though your devotees, bound by karma and conditioning of mind, are caught in the net of destiny that arouses troubles and bondage, still they are not afraid of the fret and fever of this world. Having realized this universe as your own existence they are not afraid of worldly difficulties, because fear exists only when there is someone else to inflict it, but when there is none other than You how can fear arise.`
        },
        {
            sanskrit: `अन्तक! मां प्रति मा दृशमेनां
क्रोधकरालतमां विदधीहि ।
शङ्करसेवनचिन्तनधीरो
भीषणभैरवशक्तिमयोऽस्मि ॥४॥`,
            transliteration: `antaka! māṁ prati mā dṛśamenāṁ
krodha-karāla-tamāṁ vidadhīhi /
śaṅkara-sevana-cintana-dhīro
bhīṣaṇa-bhairava-śakti-mayo‘smi //4//`,
            translation: `O angel of death, do not look towards me with wrathful and frightening eyes as I am always absorbed in the worship of Lord Śiva. Through constant devotion, meditation and reflection, I have become steadfast and courageous, one with the energy of the terrifying Bhairava, thus, your dreadful and frightening looks can do me no harm.`
        },
        {
            sanskrit: `इत्थमुपोढ़भवन्मयसंवि-
द्दीधितिदारितभूरितमिस्रः।
मृत्युर्यमान्तककर्मपिशाचै-
र्नाथ! नमोऽस्तु न जातु बिभेमि ॥५॥`,
            transliteration: `ittham-upoḍha-bhavan-maya-saṁvid-
dīdhiti-dārita-bhūri-tamisraḥ /
mṛtyur-yamāntaka-karma-piśācair-
nātha! namo‘stu na jatu bibhemi //5//`,
            translation: `O Lord Bhairava, I offer salutations to you who has awakened me to the realization that everything in existence is you alone. As a result of this awakening, the darkness of my mind has been destroyed and I am neither frightened of the evil family of demons nor am I afraid of Yama, the fearful Lord of death.`
        },
        {
            sanskrit: `प्रोदितसत्यविबोधमरीचि-
प्रोक्षितविश्वपदार्थसतत्त्वः ।
भावपरामृतनिर्भरपूर्णे
त्वय्यऽहमात्मनि निर्वृत्तिमेमि ॥६॥`,
            transliteration: `prodita-satya-vibodha-marīci-
prokṣita-viśva-padārtha-satattvaḥ /
bhāva-parāmṛta-nirbhara-pūrṇe
tvayya‘ham-ātmani nirvṛttim-emi //6//`,
            translation: `O Lord Śiva, it is through your existence, revealed to me by real knowledge, that I realize all attachments and all that exists in this universe is activated by you. It is by this awakening that my mind becomes saturated with immortal devotion and I experience supreme bliss.`
        },
        {
            sanskrit: `मानसगोचरमेति यदैव
क्लेशदशाऽतनुतापविधात्री ।
नाथ! तदैव मम त्वदभेद-
स्तोत्रपराऽमृतवृष्टिरुदेति ॥७॥`,
            transliteration: `mānasa-gocaram-eti yadaiva
kleśa-daśā’tanu-tāpa-vidhātrī /
nātha! tadaiva mama tvad-abheda-
stotra-parā’mṛta-vṛṣṭirud-eti // 7 //`,
            translation: `O Lord, sometimes I feel misery which arouses torment in my mind, but at that same moment, blessed by a shower of your grace, a clean and clear vision of my oneness with you arises, the impact of which my mind feels appeased.`
        },
        {
            sanskrit: `शङ्कर! सत्यमिदं व्रतदान-
स्नानतपो भवतापविनाशि ।
तावकशास्त्रपराऽमृतचिन्ता
स्यन्दति चेतसि निर्वृत्तिधाराम् ॥८॥`,
            transliteration: `śaṅkara! satyam-idaṁ vrata-dāna-
snāna-tapo bhava-tāpa-vināśi /
tāvaka-śāstra-parā’mṛta-cintā
syandati cetasi nirvṛtti-dhārām //8//`,
            translation: `O Lord Śiva, it is said that through charity, ritual bath and the practices of penance the troubles of worldly existence subside, but even more than this, by remembrance of the sacred śāstras and your words alone the current of immortality like a stream of peace enters my heart.`
        },
        {
            sanskrit: `नृत्यति गायति हृष्यति गाढं
संविदियं मम भैरवनाथ! ।
त्वां प्रियमाप्य सुदर्शनमेकं
दुर्लभमन्यजनैः समयज्ञम् ॥९॥`,
            transliteration: `nṛtyati gāyati hṛṣyati gāḍhaṁ
saṁvid-iyaṁ mama bhairava-nātha /
tvāṁ priyam-āpya sudarśanam-ekaṁ
durlabham-anya-janaiḥ sama-yajñam //9//`,
            translation: `O Lord Bhairava, through my utmost faith I have perceived you in the unique sacrifice of oneness, which otherwise is not possible though performing mountains of rituals. Being filled with your presence my consciousness intensely dances and sings, enjoying its own ecstasy.`
        },
        {
            sanskrit: `वसुरसपौषे कृष्णदशम्या-
मभिनवगुप्तः स्तवमिदमकरोत् ।
येन विभुर्भवमरुसन्तापं
शमयति झटिति जनस्य दयालुः॥१०॥`,
            transliteration: `vasu-rasa-pauṣe kṛṣṇa-daśamyāṁ-
abhinavaguptaḥ stavam-idam-akarot /
yena vibhur-bhava-maru-santāpaṁ
śamayati jhaṭiti janasya dayāluḥ //10//`,
            translation: `O compassionate Lord, under the influence of your glory and for the benefit of your worshipers, I Abhinavagupta have composed this hymn. By meditation and recitation of this hymn within a moment that merciful Lord Bhairava destroys the torments and sufferings springing from this wilderness of saṁsāra.`
        }
    ]
  },
  {
    id: '3',
    title: 'Hanuman Chalisa',
    audio: 'hanuman_chalisa.mp3',
    stanzas: [
        {
            sanskrit: `श्रीगुरु चरन सरोज रज निज मनु मुकुरु सुधारि ।
बरनउँ रघुबर बिमल जसु जो दायकु फल चारि ॥`,
            transliteration: `Shri guru charan saroj raj neej manu mukur sudhari ।
Baranu raghubar bimal jasu jo dayaku phal chari ॥`,
            translation: `Cleansing the mirror of my mind with the dust from the lotus feet of the divine Guru, I describe the pure glory of the best of the Raghus, which bestows the four fruits of life.`
        },
        {
            sanskrit: `बुद्धिहीन तनु जानिके सुमिरौं पवन-कुमार ।
बल बुधि बिद्या देहु मोहिं हरहु कलेस बिकार ॥`,
            transliteration: `Buddhi heen tanu janike sumero pavan kumar ।
Bal buddhi bidya deu mohi harau kales bikar ॥`,
            translation: `Knowing my body to be devoid of intelligence, I remember the Son of the Wind. Grant me strength, wisdom, and knowledge, and remove my afflictions and blemishes.`
        },
        {
            sanskrit: `जय हनुमान ज्ञान गुन सागर ।
जय कपीस तिहुँ लोक उजागर ॥`,
            transliteration: `Jai Hanuman gyan gun sagar ।
Jai kapis tihu lok ujagar ॥`,
            translation: `Victory to Hanuman, the ocean of wisdom and virtue. Victory to the Lord of Monkeys, who is the enlightener of the three worlds.`
        },
        {
            sanskrit: `राम दूत अतुलित बल धामा ।
अंजनि पुत्र पवनसुत नामा ॥`,
            transliteration: `Ram doot atulit bal dhama ।
Anjani putra pavan sut nama ॥`,
            translation: `You are the divine messenger of Shri Ram. The repository of immeasurable strength, though known only as Son of Pavan (Wind), born of Anjani.`
        },
        {
            sanskrit: `महावीर विक्रम बजरंगी ।
कुमति निवार सुमति के संगी ॥`,
            transliteration: `Mahavir vikram bajrangi ।
Kumati nivar sumati ke sangi ॥`,
            translation: `With limbs as sturdy as Vajra (The mace of God Indra) you are valiant and brave. On you attends good sense and wisdom. You dispel the darkness of evil thoughts.`
        },
        {
            sanskrit: `कंचन वरन विराज सुवेसा ।
कानन कुंडल कुंचित केसा ॥`,
            transliteration: `Kanchan varan viraj suvesa ।
Kanan kundal kunchit kesa ॥`,
            translation: `Your physique is beautiful golden coloured and your dress is pretty. You wear ear rings and have long curly hair.`
        },
        {
            sanskrit: `हाथ वज्र और ध्वजा विराजै ।
काँधे मूंज जनेऊ साजै ॥`,
            transliteration: `Hath vajra aur dhvaja viraje ।
Kandhe moonj janehu sajai ॥`,
            translation: `You carry in your hand a lightning bolt along with a victory (kesari) flag and wear the sacred thread on your shoulder.`
        },
        {
            sanskrit: `शंकर सुवन केसरी नंदन ।
तेज प्रताप महा जग वंदन ॥`,
            transliteration: `Shankar suvan kesari nandan ।
Tej pratap maha jag vandan ॥`,
            translation: `As a descendant of Lord Sankar, you are a comfort and pride of Shri Kesari. With the lustre of your vast sway, you are propitiated all over the universe.`
        },
        {
            sanskrit: `विद्यावान गुनी अति चातुर ।
राम काज करिबे को आतुर ॥`,
            transliteration: `Vidyavan guni ati chatur ।
Ram kaj karibe ko atur ॥`,
            translation: `You are the repository of learning, virtuous and fully accomplished, always keen to carry out the behest's of Shri Ram.`
        },
        {
            sanskrit: `प्रभु चरित्र सुनिबे को रसिया ।
राम लखन सीता मन बसिया ॥`,
            transliteration: `Prabhu charitra sunibe ko rasiya ।
Ram Lakhan Sita man basiya ॥`,
            translation: `You are an ardent listener, always so keen to listen to the narration of Shri Ram's life stories. Your heart is filled with what Shri Ram stood for. You therefore always dwell in the hearts of Shri Ram, Lakshman and Sita.`
        },
        {
            sanskrit: `सूक्ष्म रूप धरि सियहिं दिखावा ।
विकट रूप धरि लंक जरावा ॥`,
            transliteration: `Sukshma roop dhari siyahi dikhava ।
Vikat roop dhari lanka jarava ॥`,
            translation: `You appeared before Sita in a diminutive form and spoke to her in humility. You assumed an awesome form and struck terror by setting Lanka on fire.`
        },
        {
            sanskrit: `भीम रूप धरि असुर संहारे ।
रामचंद्र के काज संवारे ॥`,
            transliteration: `Bhim roop dhari asur sanghare ।
Ramachandra ke kaj sanvare ॥`,
            translation: `With overwhelming might you destroyed the Asuras (demons) and performed all tasks assigned to you by Shri Ram with great skill.`
        },
        {
            sanskrit: `लाय सजीवन लखन जियाये ।
श्रीरघुवीर हरषि उर लाये ॥`,
            transliteration: `Laye sanjivan Lakhan jiyaye ।
Shri Raghuvir harashi ur laye ॥`,
            translation: `You brought Sanjivan (A herb that revives life) and restored Lakshman back to life, Shri Raghuvir (Shri Ram) cheerfully embraced you with his heart full of joy.`
        },
        {
            sanskrit: `रघुपति कीन्ही बहुत बड़ाई ।
तुम मम प्रिय भरतहि सम भाई ॥`,
            transliteration: `Raghupati kinhi bahut badai ।
Tum mam priye Bharathi sam bhai ॥`,
            translation: `Shri Raghupati (Shri Ram) lustily extolled your excellence and said: "You are as dear to me as my own brother Bharat."`
        },
        {
            sanskrit: `सहस बदन तुम्हरो यश गावें ।
अस कहि श्रीपति कंठ लगावें ॥`,
            transliteration: `Sahas badan tumharo yash gaave ।
As kahi Shripati kanth lagaave ॥`,
            translation: `Thousands of living beings are chanting hymns of your glories; saying thus, Shri Ram warmly hugged him (Shri Hanuman).`
        },
        {
            sanskrit: `सनकादिक ब्रह्मादि मुनीसा ।
नारद सारद सहित अहीसा ॥`,
            transliteration: `Sanakadik Brahmadi Muneesa ।
Narad Sarad sahit Aheesa ॥`,
            translation: `When prophets like Sanak, even the Sage like Lord Brahma, the great hermit Narad himself, Goddess Saraswati and Aheesa (one of immeasurable dimensions).`
        },
        {
            sanskrit: `यम कुबेर दिगपाल जहां ते ।
कवि कोविद कहि सके कहां ते ॥`,
            transliteration: `Yam Kuber Digpal jahan te ।
Kavi kovid kahi sake kahan te ॥`,
            translation: `Even Yamraj (God of Death) Kuber (God of Wealth) and the Digpals (deputies guarding the four corners of the Universe) have been vying with one another in offering homage to your glories. How then, can a mere poet give adequate expression of your super excellence.`
        },
        {
            sanskrit: `तुम उपकार सुग्रीवहिं कीन्हा ।
राम मिलाय राजपद दीन्हा ॥`,
            transliteration: `Tum upkar Sugreevahin keenha ।
Ram milaye rajpad deenha ॥`,
            translation: `You rendered a great service to Sugriv. You united him with Shri Ram and he installed him on the Royal Throne.`
        },
        {
            sanskrit: `तुम्हरो मंत्र विभीषन माना ।
लंकेश्वर भये सब जग जाना ॥`,
            transliteration: `Tumharo mantra Vibheeshan mana ।
Lankeshwar bhaye sub jag jana ॥`,
            translation: `By heeding your advice, Vibhishan became Lord of Lanka. This is known all over the Universe.`
        },
        {
            sanskrit: `जुग सहस्र योजन पर भानू ।
लील्यो ताहि मधुर फल जानू ॥`,
            transliteration: `Yug sahastra jojan par Bhanu ।
Leelyo tahi madhur phal janu ॥`,
            translation: `On your own you dashed upon the Sun, which is at a fabulous distance of thousands of miles, thinking it to be a sweet luscious fruit.`
        },
        {
            sanskrit: `प्रभु मुद्रिका मेलि मुख माहीं ।
जलधि लांघि गये अचरज नाहीं ॥`,
            transliteration: `Prabhu mudrika meli mukh mahee ।
Jaladhi langhi gaye achraj nahee ॥`,
            translation: `Carrying the Lord's Signet Ring in your mouth, there is hardly any wonder that you easily leapt across the ocean.`
        },
        {
            sanskrit: `दुर्गम काज जगत के जेते ।
सुगम अनुग्रह तुम्हरे तेते ॥`,
            transliteration: `Durgaam kaj jagat ke jete ।
Sugam anugraha tumhre tete ॥`,
            translation: `The burden of all difficult tasks of the world become light with your kind grace.`
        },
        {
            sanskrit: `राम दुआरे तुम रखवारे ।
होत न आज्ञा बिनु पैसारे ॥`,
            transliteration: `Ram duware tum rakhvare ।
Hoat na agya binu paisare ॥`,
            translation: `You are the sentry at the door of Shri Ram's Divine Abode. No one can enter it without your permission.`
        },
        {
            sanskrit: `सब सुख लहै तुम्हारी सरना ।
तुम रक्षक काहू को डरना ॥`,
            transliteration: `Sub sukh lahai tumhari sarna ।
Tum rakshak kahu ko dar na ॥`,
            translation: `All comforts of the world lie at your feet. The devotees enjoy all divine pleasures and feel fearless under your benign Protection.`
        },
        {
            sanskrit: `आपन तेज सम्हारो आपै ।
तीनों लोक हांक तें कांपै ॥`,
            transliteration: `Aapan tej samharo aapai ।
Teenhon lok hank te kanpai ॥`,
            translation: `You alone are befitted to carry your own splendid valour. All the three worlds (entire universe) tremor at your thunderous call.`
        },
        {
            sanskrit: `भूत पिशाच निकट नहिं आवै ।
महावीर जब नाम सुनावै ॥`,
            transliteration: `Bhoot pisach nikat nahin aavai ।
Mahavir jab naam sunavai ॥`,
            translation: `All the ghosts, demons and evil forces keep away, with the sheer mention of your great name, O Mahaveer!!`
        },
        {
            sanskrit: `नासै रोग हरै सब पीरा ।
जपत निरंतर हनुमत बीरा ॥`,
            transliteration: `Nase rog harai sab peera ।
Japat nirantar Hanumant beera ॥`,
            translation: `All diseases, pain and suffering disappear on reciting regularly Shri Hanuman's holy name.`
        },
        {
            sanskrit: `संकट तें हनुमान छुड़ावै ।
मन क्रम वचन ध्यान जो लावै ॥`,
            transliteration: `Sankat te Hanuman chudavai ।
Man Karam Vachan dyan jo lavai ॥`,
            translation: `Those who remember Shri Hanuman in thought, words and deeds with sincerity and faith, are rescued from all crises in life.`
        },
        {
            sanskrit: `सब पर राम तपस्वी राजा ।
तिन के काज सकल तुम साजा ॥`,
            transliteration: `Sub par Ram tapasvee raja ।
Tin ke kaj sakal Tum saja ॥`,
            translation: `All who hail, worship and have faith in Shri Ram as the Supreme Lord and the king of penance. You make all their difficult tasks very easy.`
        },
        {
            sanskrit: `और मनोरथ जो कोई लावै ।
सोइ अमित जीवन फल पावै ॥`,
            transliteration: `Aur manorath jo koi lavai ।
Sohi amit jeevan phal pavai ॥`,
            translation: `Whosoever comes to you for fulfillment of any desire with faith and sincerity, will he alone secure the imperishable fruit of human life.`
        },
        {
            sanskrit: `चारों युग परताप तुम्हारा ।
है परसिद्ध जगत उजियारा ॥`,
            transliteration: `Charon Yug partap tumhara ।
Hai persidh jagat ujiyara ॥`,
            translation: `All through the four ages your magnificent glory is acclaimed far and wide. Your fame is radiantly acclaimed all over the Cosmos.`
        },
        {
            sanskrit: `साधु संत के तुम रखवारे ।
असुर निकंदन राम दुलारे ॥`,
            transliteration: `Sadhu Sant ke tum Rakhware ।
Asur nikandan Ram dulhare ॥`,
            translation: `You are Saviour and the guardian angel of Saints and Sages and destroy all Demons. You are the angelic darling of Shri Ram.`
        },
        {
            sanskrit: `अष्ट सिद्धि नव निधि के दाता ।
अस वर दीन जानकी माता ॥`,
            transliteration: `Ashta sidhi nav nidhi ke dhata ।
As var deen Janki mata ॥`,
            translation: `You can grant to any one, any yogic power of Eight Siddhis (power to become light and heavy at will) and Nine Nidhis (Riches, comfort, power, prestige, fame, sweet relationship etc.) This boon has been conferred upon you by Mother Janki.`
        },
        {
            sanskrit: `राम रसायन तुम्हरे पासा ।
सदा रहो रघुपति के दासा ॥`,
            transliteration: `Ram rasayan tumhare pasa ।
Sada raho Raghupati ke dasa ॥`,
            translation: `You possess the power of devotion to Shri Ram. In all rebirths you will always remain Shri Raghupati's most dedicated disciple.`
        },
        {
            sanskrit: `तुम्हरे भजन राम को पावै ।
जनम जनम के दुख बिसरावै ॥`,
            transliteration: `Tumhare bhajan Ram ko pavai ।
Janam janam ke dukh bisravai ॥`,
            translation: `Through hymns sung in devotion to you, one can find Shri Ram and become free from sufferings of several births.`
        },
        {
            sanskrit: `अंत काल रघुवीर पुर जाई ।
जहाँ जन्म हरि-भक्त कहाई ॥`,
            transliteration: `Anth kaal Raghuvir pur jayee ।
Jahan janam Hari-Bakht Kahayee ॥`,
            translation: `If at the time of death one enters the Divine Abode of Shri Ram, thereafter in all future births he is born as the Lord's devotee.`
        },
        {
            sanskrit: `और देवता चित्त न धरहीं ।
हनुमत सेइ सर्व सुख करहीं ॥`,
            transliteration: `Aur Devta Chit na dharehi ।
Hanumanth se hi sarve sukh karehi ॥`,
            translation: `One need not entertain any other deity for propitiation, as devotion of Shri Hanuman alone can give all happiness.`
        },
        {
            sanskrit: `संकट कटै मिटै सब पीरा ।
जो सुमिरै हनुमत बलबीरा ॥`,
            transliteration: `Sankat kate mite sab peera ।
Jo sumirai Hanumat Balbeera ॥`,
            translation: `One is freed from all the sufferings and ill fated contingencies of rebirths in the world. One who adores and remembers Shri Hanuman.`
        },
        {
            sanskrit: `जय जय जय हनुमान गोसाईं ।
कृपा करहु गुरुदेव की नाईं ॥`,
            transliteration: `Jai Jai Jai Hanuman Gosahin ।
Kripa Karahu Gurudev ki nyahin ॥`,
            translation: `Hail, Hail, Hail, Shri Hanuman, Lord of senses. Let your victory over the evil be firm and final. Bless me in the capacity as my supreme guru (teacher).`
        },
        {
            sanskrit: `जो शत बार पाठ कर कोई ।
छूटहिं बंदि महा सुख होई ॥`,
            transliteration: `Jo sat bar path kare kohi ।
Chutehi bandhi maha sukh hohi ॥`,
            translation: `One who recites Chalisa one hundred times, becomes free from the bondage of life and death and enjoys the highest bliss at last.`
        },
        {
            sanskrit: `जो यह पढ़े हनुमान चालीसा ।
होय सिद्धि साखी गौरीसा ॥`,
            transliteration: `Jo yah padhe Hanuman Chalisa ।
Hoye siddhi sakhi Gaureesa ॥`,
            translation: `All those who recite Hanuman Chalisa (The forty Chaupais) regularly are sure to be benedicted. Such is the evidence of no less a witness as Bhagwan Sankar.`
        },
        {
            sanskrit: `तुलसीदास सदा हरि चेरा ।
कीजै नाथ हृदय महँ डेरा ॥`,
            transliteration: `Tulsidas sada hari chera ।
Keejai Das Hrdaye mein dera ॥`,
            translation: `Tulsidas as a bonded slave of the Divine Master, stays perpetually at his feet, he prays "Oh Lord! You enshrine within my heart & soul."`
        },
        {
            sanskrit: `पवनतनय संकट हरन मंगल मूर्ति रूप ।
राम लखन सीता सहित हृदय बसहु सुर भूप ॥`,
            transliteration: `Pavan tanay sankat harana mangal murti roop ।
Ram Lakhan Sita sahit hriday basahu sur bhuup ॥`,
            translation: `O Son of the Wind, remover of distress, embodiment of auspiciousness, reside in my heart along with Ram, Lakhan, and Sita, O King of Gods.`
        },
    ]
  },
  {
    id: '4',
    title: 'Aṣṭottara Śatanāmāvalī of Baṭuka Bhairava',
    audio: 'Ashtottara_bhairav.mp3',
    stanzas: [
        { sanskrit: `ॐ भैरवाय नमः।`, transliteration: `Om Bhairavaya Namah।`, translation: `Salutations to Bhairava, the terrifying one.` },
        { sanskrit: `ॐ भूतनाथाय नमः।`, transliteration: `Om Bhutanathaya Namah।`, translation: `Salutations to the Lord of all beings.` },
        { sanskrit: `ॐ भूतात्मने नमः।`, transliteration: `Om Bhutatmane Namah।`, translation: `Salutations to the soul of all beings.` },
        { sanskrit: `ॐ भूतभावनाय नमः।`, transliteration: `Om Bhutabhavanaya Namah।`, translation: `Salutations to the creator of all beings.` },
        { sanskrit: `ॐ क्षेत्रज्ञाय नमः।`, transliteration: `Om Kshetrajnaya Namah।`, translation: `Salutations to the knower of the field (body).` },
        { sanskrit: `ॐ क्षेत्रपालाय नमः।`, transliteration: `Om Kshetrapalaya Namah।`, translation: `Salutations to the protector of the field.` },
        { sanskrit: `ॐ क्षेत्रदाय नमः।`, transliteration: `Om Kshetradaya Namah।`, translation: `Salutations to the bestower of the field.` },
        { sanskrit: `ॐ क्षत्रियाय नमः।`, transliteration: `Om Kshatriyaya Namah।`, translation: `Salutations to the warrior.` },
        { sanskrit: `ॐ विराजे नमः।`, transliteration: `Om Viraje Namah।`, translation: `Salutations to the sovereign one.` },
        { sanskrit: `ॐ श्मशानवासिने नमः।`, transliteration: `Om Shmashanavasine Namah।`, translation: `Salutations to the one who dwells in cremation grounds.` },
        { sanskrit: `ॐ मांसाशिने नमः।`, transliteration: `Om Mamsashine Namah।`, translation: `Salutations to the eater of flesh.` },
        { sanskrit: `ॐ खर्पराशिने नमः।`, transliteration: `Om Kharparashine Namah।`, translation: `Salutations to the one who consumes from a skull-cup.` },
        { sanskrit: `ॐ स्मरान्तकाय नमः।`, transliteration: `Om Smarantakaya Namah।`, translation: `Salutations to the destroyer of desire (Kamadeva).` },
        { sanskrit: `ॐ रक्तपाय नमः।`, transliteration: `Om Raktapaya Namah।`, translation: `Salutations to the drinker of blood.` },
        { sanskrit: `ॐ पानपाय नमः।`, transliteration: `Om Panapaya Namah।`, translation: `Salutations to the drinker of libations.` },
        { sanskrit: `ॐ सिद्धाय नमः।`, transliteration: `Om Siddhaya Namah।`, translation: `Salutations to the perfected one.` },
        { sanskrit: `ॐ सिद्धिदाय नमः।`, transliteration: `Om Siddhidaya Namah।`, translation: `Salutations to the bestower of psychic powers.` },
        { sanskrit: `ॐ सिद्धिसेविताय नमः।`, transliteration: `Om Siddhisevitaya Namah।`, translation: `Salutations to the one served by siddhis.` },
        { sanskrit: `ॐ कङ्कालाय नमः।`, transliteration: `Om Kankalaya Namah।`, translation: `Salutations to the one who bears a skeleton.` },
        { sanskrit: `ॐ कालशमनाय नमः।`, transliteration: `Om Kalashamanaya Namah।`, translation: `Salutations to the pacifier of time/death.` },
        { sanskrit: `ॐ कलाकाष्ठातनवे नमः।`, transliteration: `Om Kalakashthatanave Namah।`, translation: `Salutations to the one whose body is time itself.` },
        { sanskrit: `ॐ कवये नमः।`, transliteration: `Om Kavaye Namah।`, translation: `Salutations to the poet/seer.` },
        { sanskrit: `ॐ त्रिनेत्राय नमः।`, transliteration: `Om Trinetraya Namah।`, translation: `Salutations to the three-eyed one.` },
        { sanskrit: `ॐ बहुनेत्राय नमः।`, transliteration: `Om Bahunetraya Namah।`, translation: `Salutations to the many-eyed one.` },
        { sanskrit: `ॐ पिङ्गललोचनाय नमः।`, transliteration: `Om Pingalalochanaya Namah।`, translation: `Salutations to the one with reddish-brown eyes.` },
        { sanskrit: `ॐ शूलपाणये नमः।`, transliteration: `Om Shulapanaye Namah।`, translation: `Salutations to the one holding a trident.` },
        { sanskrit: `ॐ खड्गपाणये नमः।`, transliteration: `Om Khadgapanaye Namah।`, translation: `Salutations to the one holding a sword.` },
        { sanskrit: `ॐ कङ्कालिने नमः।`, transliteration: `Om Kankaline Namah।`, translation: `Salutations to the one adorned with bones.` },
        { sanskrit: `ॐ धूम्रलोचनाय नमः।`, transliteration: `Om Dhumralochanaya Namah।`, translation: `Salutations to the one with smoke-colored eyes.` },
        { sanskrit: `ॐ अभीरवे नमः।`, transliteration: `Om Abhirave Namah।`, translation: `Salutations to the fearless one.` },
        { sanskrit: `ॐ भैरवीनाथाय नमः।`, transliteration: `Om Bhairavinathaya Namah।`, translation: `Salutations to the Lord of Bhairavi.` },
        { sanskrit: `ॐ भूतपाय नमः।`, transliteration: `Om Bhutapaya Namah।`, translation: `Salutations to the protector of beings.` },
        { sanskrit: `ॐ योगिनीपतये नमः।`, transliteration: `Om Yoginipataye Namah।`, translation: `Salutations to the Lord of the Yoginis.` },
        { sanskrit: `ॐ धनदाय नमः।`, transliteration: `Om Dhanadaya Namah।`, translation: `Salutations to the giver of wealth.` },
        { sanskrit: `ॐ धनहारिणे नमः।`, transliteration: `Om Dhanaharine Namah।`, translation: `Salutations to the remover of wealth.` },
        { sanskrit: `ॐ धनवते नमः।`, transliteration: `Om Dhanavate Namah।`, translation: `Salutations to the wealthy one.` },
        { sanskrit: `ॐ प्रतिभानवते नमः।`, transliteration: `Om Pratibhanavate Namah।`, translation: `Salutations to the one with brilliant intellect.` },
        { sanskrit: `ॐ नागहाराय नमः।`, transliteration: `Om Nagaharaya Namah।`, translation: `Salutations to the one with a necklace of snakes.` },
        { sanskrit: `ॐ नागकेशाय नमः।`, transliteration: `Om Nagakeshaya Namah।`, translation: `Salutations to the one with hair of snakes.` },
        { sanskrit: `ॐ व्योमकेशाय नमः।`, transliteration: `Om Vyomakeshaya Namah।`, translation: `Salutations to the one with sky-like hair.` },
        { sanskrit: `ॐ कपालभृते नमः।`, transliteration: `Om Kapalabhrite Namah।`, translation: `Salutations to the bearer of a skull.` },
        { sanskrit: `ॐ कालाय नमः।`, transliteration: `Om Kalaya Namah।`, translation: `Salutations to Time itself.` },
        { sanskrit: `ॐ कपालमालिने नमः।`, transliteration: `Om Kapalamaline Namah।`, translation: `Salutations to the one wearing a garland of skulls.` },
        { sanskrit: `ॐ कमनीयाय नमः।`, transliteration: `Om Kamaniyaya Namah।`, translation: `Salutations to the desirable one.` },
        { sanskrit: `ॐ कलानिधये नमः।`, transliteration: `Om Kalanidhaye Namah।`, translation: `Salutations to the repository of arts.` },
        { sanskrit: `ॐ त्रिलोचनाय नमः।`, transliteration: `Om Trilochanaya Namah।`, translation: `Salutations to the three-eyed one.` },
        { sanskrit: `ॐ ज्वलन्नेत्राय नमः।`, transliteration: `Om Jvalannetraya Namah।`, translation: `Salutations to the one with flaming eyes.` },
        { sanskrit: `ॐ त्रिशिखिने नमः।`, transliteration: `Om Trishikhine Namah।`, translation: `Salutations to the three-crested one.` },
        { sanskrit: `ॐ त्रिलोकपाय नमः।`, transliteration: `Om Trilokapaya Namah।`, translation: `Salutations to the protector of the three worlds.` },
        { sanskrit: `ॐ त्रिनेत्रतनयाय नमः।`, transliteration: `Om Trinetratanayaya Namah।`, translation: `Salutations to the son of the three-eyed one (Shiva).` },
        { sanskrit: `ॐ डिम्भाय नमः।`, transliteration: `Om Dimbhaya Namah।`, translation: `Salutations to the child form.` },
        { sanskrit: `ॐ शान्ताय नमः।`, transliteration: `Om Shantaya Namah।`, translation: `Salutations to the peaceful one.` },
        { sanskrit: `ॐ शान्तजनप्रियाय नमः।`, transliteration: `Om Shantajanapriyaya Namah।`, translation: `Salutations to the one dear to peaceful people.` },
        { sanskrit: `ॐ बटुकाय नमः।`, transliteration: `Om Batukaya Namah।`, translation: `Salutations to the boy form.` },
        { sanskrit: `ॐ बहुवेषाय नमः।`, transliteration: `Om Bahuveshaya Namah।`, translation: `Salutations to the one with many forms.` },
        { sanskrit: `ॐ खट्वाङ्गवरधारकाय नमः।`, transliteration: `Om Khatvangavaradharakaya Namah।`, translation: `Salutations to the bearer of the skull-topped staff.` },
        { sanskrit: `ॐ भूताध्यक्षाय नमः।`, transliteration: `Om Bhutadhyakshaya Namah।`, translation: `Salutations to the overseer of beings.` },
        { sanskrit: `ॐ पशुपतये नमः।`, transliteration: `Om Pashupataye Namah।`, translation: `Salutations to the Lord of all souls (Pashus).` },
        { sanskrit: `ॐ भिक्षुकाय नमः।`, transliteration: `Om Bhikshukaya Namah।`, translation: `Salutations to the mendicant.` },
        { sanskrit: `ॐ परिचारकाय नमः।`, transliteration: `Om Paricharakaya Namah।`, translation: `Salutations to the attendant.` },
        { sanskrit: `ॐ धूर्ताय नमः।`, transliteration: `Om Dhurtaya Namah।`, translation: `Salutations to the cunning one.` },
        { sanskrit: `ॐ दिगम्बराय नमः।`, transliteration: `Om Digambaraya Namah।`, translation: `Salutations to the sky-clad one.` },
        { sanskrit: `ॐ शौरिणे नमः।`, transliteration: `Om Shaurine Namah।`, translation: `Salutations to the heroic one.` },
        { sanskrit: `ॐ हरिणाय नमः।`, transliteration: `Om Harinaya Namah।`, translation: `Salutations to the one who is like a deer (or remover of sins).` },
        { sanskrit: `ॐ पाण्डुलोचनाय नमः।`, transliteration: `Om Pandulochanaya Namah।`, translation: `Salutations to the one with pale eyes.` },
        { sanskrit: `ॐ प्रशान्ताय नमः।`, transliteration: `Om Prashantaya Namah।`, translation: `Salutations to the supremely calm one.` },
        { sanskrit: `ॐ शान्तिदाय नमः।`, transliteration: `Om Shantidaya Namah।`, translation: `Salutations to the bestower of peace.` },
        { sanskrit: `ॐ सिद्धाय नमः।`, transliteration: `Om Siddhaya Namah।`, translation: `Salutations to the accomplished one.` },
        { sanskrit: `ॐ शङ्करप्रियबान्धवाय नमः।`, transliteration: `Om Shankarapriyabandhavaya Namah।`, translation: `Salutations to the dear kinsman of Shankara.` },
        { sanskrit: `ॐ अष्टमूर्तये नमः।`, transliteration: `Om Ashtamurtaye Namah।`, translation: `Salutations to the one with eight forms.` },
        { sanskrit: `ॐ निधीशाय नमः।`, transliteration: `Om Nidhishaya Namah।`, translation: `Salutations to the lord of treasures.` },
        { sanskrit: `ॐ ज्ञानचक्षुषे नमः।`, transliteration: `Om Jnanachakshushe Namah।`, translation: `Salutations to the one whose eye is knowledge.` },
        { sanskrit: `ॐ तपोमयाय नमः।`, transliteration: `Om Tapomayaya Namah।`, translation: `Salutations to the one full of austerity.` },
        { sanskrit: `ॐ अष्टाधाराय नमः।`, transliteration: `Om Ashtadharaya Namah।`, translation: `Salutations to the support of the eight elements.` },
        { sanskrit: `ॐ षडाधाराय नमः।`, transliteration: `Om Shadadharaya Namah।`, translation: `Salutations to the support of the six chakras.` },
        { sanskrit: `ॐ सर्पयुक्ताय नमः।`, transliteration: `Om Sarpayuktaya Namah।`, translation: `Salutations to the one adorned with serpents.` },
        { sanskrit: `ॐ शिखीसख्ये नमः।`, transliteration: `Om Shikhisakhye Namah।`, translation: `Salutations to the friend of fire (or peacocks).` },
        { sanskrit: `ॐ भूधराय नमः।`, transliteration: `Om Bhudharaya Namah।`, translation: `Salutations to the supporter of the earth.` },
        { sanskrit: `ॐ भूधराधीशाय नमः।`, transliteration: `Om Bhudharadhishaya Namah।`, translation: `Salutations to the lord of the earth-supporter (mountains).` },
        { sanskrit: `ॐ भूपतये नमः।`, transliteration: `Om Bhupataye Namah।`, translation: `Salutations to the lord of the earth.` },
        { sanskrit: `ॐ भूधरात्मजाय नमः।`, transliteration: `Om Bhudharatmajaya Namah।`, translation: `Salutations to the son of the mountain-bearer.` },
        { sanskrit: `ॐ कङ्कालधारिणे नमः।`, transliteration: `Om Kankaladharine Namah।`, translation: `Salutations to the bearer of the skeleton.` },
        { sanskrit: `ॐ मुण्डिने नमः।`, transliteration: `Om Mundine Namah।`, translation: `Salutations to the tonsured one.` },
        { sanskrit: `ॐ नागयज्ञोपवीतकाय नमः।`, transliteration: `Om Nagayajnopavitakaya Namah।`, translation: `Salutations to the one with a snake as a sacred thread.` },
        { sanskrit: `ॐ जृम्भणाय नमः।`, transliteration: `Om Jrimbhanaya Namah।`, translation: `Salutations to the one who causes yawning/expansion.` },
        { sanskrit: `ॐ मोहनाय नमः।`, transliteration: `Om Mohanaya Namah।`, translation: `Salutations to the bewilderer.` },
        { sanskrit: `ॐ स्तम्भिने नमः।`, transliteration: `Om Stambhine Namah।`, translation: `Salutations to the one who paralyzes.` },
        { sanskrit: `ॐ मारणाय नमः।`, transliteration: `Om Maranaya Namah।`, translation: `Salutations to the one who causes death.` },
        { sanskrit: `ॐ क्षोभणाय नमः।`, transliteration: `Om Kshobhanaya Namah।`, translation: `Salutations to the one who causes agitation.` },
        { sanskrit: `ॐ शुद्धाय नमः।`, transliteration: `Om Shuddhaya Namah।`, translation: `Salutations to the pure one.` },
        { sanskrit: `ॐ नीलाञ्जनप्रख्याय नमः।`, transliteration: `Om Nilanjanaprakhyaya Namah।`, translation: `Salutations to the one who resembles blue collyrium.` },
        { sanskrit: `ॐ दैत्यघ्ने नमः।`, transliteration: `Om Daityaghne Namah।`, translation: `Salutations to the slayer of demons.` },
        { sanskrit: `ॐ मुण्डभूषिताय नमः।`, transliteration: `Om Mundabhushitaya Namah।`, translation: `Salutations to the one adorned with skulls.` },
        { sanskrit: `ॐ बलिभुजे नमः।`, transliteration: `Om Balibhuje Namah।`, translation: `Salutations to the enjoyer of offerings.` },
        { sanskrit: `ॐ बलिभुङ्नाथाय नमः।`, transliteration: `Om Balibhunnathaya Namah।`, translation: `Salutations to the lord of the enjoyers of offerings.` },
        { sanskrit: `ॐ बालाय नमः।`, transliteration: `Om Balaya Namah।`, translation: `Salutations to the child.` },
        { sanskrit: `ॐ बालपराक्रमाय नमः।`, transliteration: `Om Balaparakramaya Namah।`, translation: `Salutations to the one with child-like valor.` },
        { sanskrit: `ॐ सर्वापत्तारणाय नमः।`, transliteration: `Om Sarvapattaranaya Namah।`, translation: `Salutations to the savior from all calamities.` },
        { sanskrit: `ॐ दुर्गाय नमः।`, transliteration: `Om Durgaya Namah।`, translation: `Salutations to the one who is difficult to attain (or remover of difficulties).` },
        { sanskrit: `ॐ दुष्टभूतनिषेविताय नमः।`, transliteration: `Om Dushtabhutanishevitaya Namah।`, translation: `Salutations to the one served by wicked beings.` },
        { sanskrit: `ॐ कामिने नमः।`, transliteration: `Om Kamine Namah।`, translation: `Salutations to the loving one.` },
        { sanskrit: `ॐ कलानिधये नमः।`, transliteration: `Om Kalanidhaye Namah।`, translation: `Salutations to the treasure of arts.` },
        { sanskrit: `ॐ कान्ताय नमः।`, transliteration: `Om Kantaya Namah।`, translation: `Salutations to the beloved one.` },
        { sanskrit: `ॐ कामिनीवशकृद्वशिने नमः।`, transliteration: `Om Kaminivashakridvashine Namah।`, translation: `Salutations to the one who controls and is controlled by the beloved.` },
        { sanskrit: `ॐ सर्वसिद्धिप्रदाय नमः।`, transliteration: `Om Sarvasiddhipradaya Namah।`, translation: `Salutations to the bestower of all accomplishments.` },
        { sanskrit: `ॐ वैद्याय नमः।`, transliteration: `Om Vaidyaya Namah।`, translation: `Salutations to the supreme physician.` },
        { sanskrit: `ॐ प्रभवे नमः।`, transliteration: `Om Prabhave Namah।`, translation: `Salutations to the supreme lord.` },
        { sanskrit: `ॐ विष्णवे नमः।`, transliteration: `Om Vishnave Namah।`, translation: `Salutations to the all-pervading one.` },
    ]
  },
  {
    id: '5',
    title: 'Bhairava Tandava Stotra',
    audio: 'Bhairav_tandav.mp3',
    stanzas: [
        {
            sanskrit: `ॐ चण्डं प्रतिचण्डं करधृतदण्डं कृतरिपुखण्डं सौख्यकरं
लोकं सुखयन्तं विलसितवन्तं प्रकटितदन्तं नृत्यकरम् ।
डमरुध्वनिशङ्खं तरलवतंसं मधुरहसन्तं लोकभरं
भज भज भूतेशं प्रकटमहेशं भैरववेषं कष्टहरम् ॥ १॥`,
            transliteration: `Om Chandam Pratichandam Karadhruta-Dandam Kritaripu-Khandam Saukhyakaram
Lokam Sukhayantam Vilasita-Vantam Prakathita-Dantam Nrutyakaram |
Damarudhvani-Shankham Tarala-Vatamsam Madhura-Hasantam Lokabharam
Bhaja Bhaja Bhutesham Prakata-Mahesham Bhairava-Vesham Kashtaharam ||1||`,
            translation: `Salutations to Bhairava, who wields the staff, who cuts down enemies, who bestows happiness and joy, who delights the world with his divine play, who reveals his teeth in a smile, and who is ever engaged in the cosmic dance. His damaru sounds like a conch, his crest ornaments flow gracefully, his sweet laughter fills the world. Worship, worship the Lord of beings, the manifest Maheshwara, Bhairava who removes all troubles.`
        },
        {
            sanskrit: `चर्चितसिन्दूरं रणभूविदूरं दुष्टविदूरं श्रीनिकरं
किङ्किणिगणरावं त्रिभुवनपावं खर्प्परसावं पुण्यभरम् ।
करुणामयवेशं सकलसुरेशं मुक्तसुकेशं पापहरं
भज भज भूतेशं प्रकटमहेशं श्रीभैरववेषं कष्टहरम् ॥ २॥`,
            transliteration: `Charchita-Sinduram Ranabhu-Viduram Dushta-Viduram Shrinikaram
Kinkini-Ganaraavam Tribhuvana-Paavam Kharrpara-Saavam Punyabharam |
Karunamaya-Vesham Sakala-Suresham Mukta-Sukesham Papa-Haram
Bhaja Bhaja Bhutesham Prakata-Mahesham Shri-Bhairava-Vesham Kashtaharam ||2||`,
            translation: `Adorned with red sindoor, far removed from the battlefield, far from the wicked, revered by all, whose anklets jingle as he dances, who purifies the three worlds, who carries a skull bowl filled with merit. He is compassionate in form, lord of all gods, with flowing hair, remover of sins. Worship, worship the Lord of beings, the manifest Maheshwara, Shri Bhairava who removes all troubles.`
        },
        {
            sanskrit: `कलिमलसंहारं मदनविहारं फणिपतिहारं शीघ्रकरं
कलुषं शमयन्तं परिभृतसन्तं मत्तदृगन्तं शुद्धतरम् ।
गतिनिन्दितकेशं नर्तनदेशं स्वच्छकशं सन्मुण्डकरं
भज भज भूतेशं प्रकटमहेशं श्रीभैरववेषं कष्टहरम् ॥ ३॥`,
            transliteration: `Kalimala-Samharam Madana-Viharam Phanipati-Haram Shighrakaram
Kalusham Shamayantam Paribhrutasantam Mattadrugantan Shuddhatarama |
Gati-Ninditakesham Nartana-Desham Svachchakasam Sanmundakaram
Bhaja Bhaja Bhutesham Prakata-Mahesham Shri-Bhairava-Vesham Kashtaharam ||3||`,
            translation: `The destroyer of the impurities of the Kali Yuga, the one who enjoys divine play, who removes the pride of serpents, who acts swiftly, who calms the agitated, who delights the hearts of devotees, who is purest of the pure. His flowing hair moves gracefully, he is the lord of dance, with clear vision, whose skull is holy. Worship, worship the Lord of beings, the manifest Maheshwara, Shri Bhairava who removes all troubles.`
        },
        {
            sanskrit: `कठिनस्तनकुम्भं सुकृतं सुलभं कालीडिम्भं खड्गधरं
वृतभूतपिशाचं स्फुटमृदुवाचं स्निग्धसुकाचं भक्तभरम् ।
तनुभाजितशेषं विलमसुदेशं कष्टसुरेशं प्रीतिनरं
भज भज भूतेशं प्रकटमहेशं श्रीभैरववेषं कष्टहरम् ॥ ४॥`,
            transliteration: `Kathina-Stana-Kumbham Sukrutam Sulabham Kalidimbham Khadgadharam
Vruta-Bhuta-Pishacham Sphuta-Mrudu-Vacham Snigdha-Sukacham Bhaktabharam |
Tanu-Bhajita-Shesham Vilama-Sudesham Kashta-Suresham Pritinaram
Bhaja Bhaja Bhutesham Prakata-Mahesham Shri-Bhairava-Vesham Kashtaharam ||4||`,
            translation: `Who holds the mountain-like breasts of the goddess Kali, who is easily pleased by good deeds, who is Kali's child, who wields a sword, who commands spirits and ghosts, whose words are soft yet clear, who is affectionate towards devotees. His body is adorned with serpents, he dwells in beautiful places, he is the lord who removes difficulties, delighting his devotees. Worship, worship the Lord of beings, the manifest Maheshwara, Shri Bhairava who removes all troubles.`
        },
        {
            sanskrit: `ललिताननचन्द्रं सुमनवितन्द्रं बोधितमन्द्रं श्रेष्ठवरं
सुखिताखिललोकं परिगतशोकं शुद्धविलोकं पुष्टिकरम् ।
वरदाभयहारं तरलिततारं क्षुद्रविदारं तुष्टिकरं
भज भज भूतेशं प्रकटमहेशं श्रीभैरववेषं कष्टहरम् ॥ ५॥`,
            transliteration: `Lalita-Anana-Chandram Sumana-Vitandram Bodhita-Mandram Shreshtavaram
Sukhita-Akhila-Lokam Parigata-Shokam Shuddha-Vilokam Pushtikaram |
Varada-Abhaya-Haram Taralita-Taram Kshudra-Vidaram Tushtikaram
Bhaja Bhaja Bhutesham Prakata-Mahesham Shri-Bhairava-Vesham Kashtaharam ||5||`,
            translation: `Whose face shines like the full moon, who is surrounded by fragrant flowers, who awakens mantras, who is the best among all, who brings joy to the world, who dispels sorrow, who is pure in vision, and who bestows nourishment. He grants boons and fearlessness, his eyes sparkle like stars, he destroys the small-minded, bringing satisfaction. Worship, worship the Lord of beings, the manifest Maheshwara, Shri Bhairava who removes all troubles.`
        },
        {
            sanskrit: `सकलायुधभारं विजनविहारं सुश्रविशारं भ्रष्टमलं
शरणागतपालं मृगमदभालं सञ्जितकालं स्वेष्टबलम् ।
पदनूपूरसिञ्जं त्रिनयनकञ्जं गुणिजनरञ्जन कुष्टहरं
भज भज भूतेशं प्रकटमहेशं श्रीभैरववेषं कष्टहरम् ॥ ६॥`,
            transliteration: `Sakala-Ayudha-Bharam Vijana-Viharam Sushrava-Visharam Brashta-Malam
Sharanagata-Palam Mrugamada-Bhalam Sanjita-Kalam Sveshta-Balam |
Pada-Nupura-Sinjam Trinayana-Kanjam Gunijana-Ranjan Kushta-Haram
Bhaja Bhaja Bhutesham Prakata-Mahesham Shri-Bhairava-Vesham Kashtaharam ||6||`,
            translation: `Who carries all weapons, who wanders in solitude, who is adorned with fragrant substances, who is free from impurities, who protects those who seek refuge, who wears musk on his forehead, who conquers time, who fulfills the wishes of his devotees. His anklets make sweet sounds, his three eyes are like lotuses, he delights the virtuous, removing diseases. Worship, worship the Lord of beings, the manifest Maheshwara, Shri Bhairava who removes all troubles.`
        },
        {
            sanskrit: `मर्दयितुसरावं प्रकटितभावं विश्वसुभावं ज्ञानपदं
रक्तांशुकजोषं परिकृततोषं नाशितदोषं सन्मतिदम् ।
कुटिलभ्रुकुटीकं ज्वरधननीकं विसरन्धीकं प्रेमभरं
भज भज भूतेशं प्रकटमहेशं श्रीभैरववेषं कष्टहरम् ॥ ७॥`,
            transliteration: `Mardayitu-Saravam Prakathita-Bhavam Viswa-Subhavam Jnana-Padam
Rakta-Amshuka-Josham Parikruta-Tosham Nashita-Dosham Sanmati-Dam |
Kutila-Bhru-Kutikam Jvara-Dhana-Nikam Visara-Ndhikam Prema-Bharam
Bhaja Bhaja Bhutesham Prakata-Mahesham Shri-Bhairava-Vesham Kashtaharam ||7||`,
            translation: `Who crushes all enemies, who reveals his nature, who is the embodiment of auspiciousness for the world, who is the abode of knowledge, who wears red garments, who is satisfied with devotion, who removes all faults, who bestows wisdom. With curved eyebrows forming a beautiful arch, who destroys fever and wealth-robbing diseases, who spreads rapidly, full of love. Worship, worship the Lord of beings, the manifest Maheshwara, Shri Bhairava who removes all troubles.`
        },
        {
            sanskrit: `परिनिर्जितकामं विलसितवामं योगिजनाभं योगेशं
बहुमद्यपनाथं गीतसुगाथं कष्टसुनाथं वीरेशम् ।
कलयन्तमशेषं भृतजनदेशं नृत्यसुरेशं वीरेशं
भज भज भूतेशं प्रकटमहेशं श्रीभैरववेषं कष्टहरम् ॥ ८॥`,
            transliteration: `Parinirjita-Kamam Vilasita-Vamam Yogijana-Bham Yogesham
Bahu-Madhya-Panatham Githa-Sugatham Kashta-Sunatham Viresham |
Kalayantam-Ashesham Bhrutajana-Desham Nrutya-Suresham Viresham
Bhaja Bhaja Bhutesham Prakata-Mahesham Shri-Bhairava-Vesham Kashtaharam ||8||`,
            translation: `Who has conquered desires, who manifests in the left-hand path, who is revered by yogis, who is the lord of yoga, who is the master of all sacrifices, who is praised in sacred songs, who is the remover of difficulties, who is the lord of heroes. Who encompasses everything, who guides devoted people, who is the lord of divine dance, the lord of heroes. Worship, worship the Lord of beings, the manifest Maheshwara, Shri Bhairava who removes all troubles.`
        }
    ]
  }
];

===============================================
File: hooks\useAudioPlayer.ts
===============================================

/*
 * =================================================================
 * FILE TO UPDATE: /hooks/useAudioPlayer.ts
 * This is the robust audio hook using `expo-audio`. It now returns
 * the raw player instance so the UI component can control it directly,
 * which is essential for lifecycle management.
 * =================================================================
 */
import { Stotra } from '@/data/stotras';
import { AudioPlayer, useAudioPlayer, useAudioPlayerStatus } from 'expo-audio';

const resolveAudioSource = (fileName: Stotra['audio']) => {
  switch (fileName) {
    case 'kal_bhairav.mp3': return require('../assets/audio/kal_bhairav.mp3');
    case 'bhairava_stotra.mp3': return require('../assets/audio/bhairava_stotra.mp3');
    case 'hanuman_chalisa.mp3': return require('../assets/audio/hanuman_chalisa.mp3');
    case 'Ashtottara_bhairav.mp3': return require('../assets/audio/Ashtottara_bhairav.mp3');
    case 'Bhairav_tandav.mp3': return require('../assets/audio/Bhairav_tandav.mp3');
    default: throw new Error(`Unknown audio file: ${fileName}`);
  }
};

// The hook now returns the player instance itself
export const useSadhanaAudioPlayer = (audioFile: Stotra['audio']): { player: AudioPlayer | null; status: any } => {
  const source = resolveAudioSource(audioFile);
  const player = useAudioPlayer(source);
  const status = useAudioPlayerStatus(player);

  return { player, status };
};

===============================================
File: scripts\reset-project.js
===============================================

#!/usr/bin/env node

/**
 * This script is used to reset the project to a blank state.
 * It deletes or moves the /app, /components, /hooks, /scripts, and /constants directories to /app-example based on user input and creates a new /app directory with an index.tsx and _layout.tsx file.
 * You can remove the `reset-project` script from package.json and safely delete this file after running it.
 */

const fs = require("fs");
const path = require("path");
const readline = require("readline");

const root = process.cwd();
const oldDirs = ["app", "components", "hooks", "constants", "scripts"];
const exampleDir = "app-example";
const newAppDir = "app";
const exampleDirPath = path.join(root, exampleDir);

const indexContent = `import { Text, View } from "react-native";

export default function Index() {
  return (
    <View
      style={{
        flex: 1,
        justifyContent: "center",
        alignItems: "center",
      }}
    >
      <Text>Edit app/index.tsx to edit this screen.</Text>
    </View>
  );
}
`;

const layoutContent = `import { Stack } from "expo-router";

export default function RootLayout() {
  return <Stack />;
}
`;

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

const moveDirectories = async (userInput) => {
  try {
    if (userInput === "y") {
      // Create the app-example directory
      await fs.promises.mkdir(exampleDirPath, { recursive: true });
      console.log(`📁 /${exampleDir} directory created.`);
    }

    // Move old directories to new app-example directory or delete them
    for (const dir of oldDirs) {
      const oldDirPath = path.join(root, dir);
      if (fs.existsSync(oldDirPath)) {
        if (userInput === "y") {
          const newDirPath = path.join(root, exampleDir, dir);
          await fs.promises.rename(oldDirPath, newDirPath);
          console.log(`➡️ /${dir} moved to /${exampleDir}/${dir}.`);
        } else {
          await fs.promises.rm(oldDirPath, { recursive: true, force: true });
          console.log(`❌ /${dir} deleted.`);
        }
      } else {
        console.log(`➡️ /${dir} does not exist, skipping.`);
      }
    }

    // Create new /app directory
    const newAppDirPath = path.join(root, newAppDir);
    await fs.promises.mkdir(newAppDirPath, { recursive: true });
    console.log("\n📁 New /app directory created.");

    // Create index.tsx
    const indexPath = path.join(newAppDirPath, "index.tsx");
    await fs.promises.writeFile(indexPath, indexContent);
    console.log("📄 app/index.tsx created.");

    // Create _layout.tsx
    const layoutPath = path.join(newAppDirPath, "_layout.tsx");
    await fs.promises.writeFile(layoutPath, layoutContent);
    console.log("📄 app/_layout.tsx created.");

    console.log("\n✅ Project reset complete. Next steps:");
    console.log(
      `1. Run \`npx expo start\` to start a development server.\n2. Edit app/index.tsx to edit the main screen.${
        userInput === "y"
          ? `\n3. Delete the /${exampleDir} directory when you're done referencing it.`
          : ""
      }`
    );
  } catch (error) {
    console.error(`❌ Error during script execution: ${error.message}`);
  }
};

rl.question(
  "Do you want to move existing files to /app-example instead of deleting them? (Y/n): ",
  (answer) => {
    const userInput = answer.trim().toLowerCase() || "y";
    if (userInput === "y" || userInput === "n") {
      moveDirectories(userInput).finally(() => rl.close());
    } else {
      console.log("❌ Invalid input. Please enter 'Y' or 'N'.");
      rl.close();
    }
  }
);


===============================================
File: services\StorageService.ts
===============================================

/*
 * =================================================================
 * FILE TO UPDATE: /services/StorageService.ts
 * Added the deleteRecitationLog function to manage individual log entries.
 * =================================================================
 */
import AsyncStorage from '@react-native-async-storage/async-storage';

// --- Japa Session Types and Functions ---
export interface JapaSession {
  malas: number;
  date: string; // ISO String format
}
const JAPA_HISTORY_KEY = 'japa_history';

// --- Recitation Log Types and Functions ---
export interface RecitationLog {
  stotraId: string;
  stotraTitle: string;
  count: number;
  date: string; // ISO String format
}
const RECITATION_LOG_KEY = 'recitation_log';

// --- Gratitude Note Types and Functions ---
export interface GratitudeNote {
  note: string;
  date: string; // ISO String format
}
const GRATITUDE_NOTES_KEY = 'gratitude_notes';

// --- Goal Types and Functions ---
export type GoalType = 'spiritual' | 'material';
export interface Goal {
  id: string; // Unique ID, e.g., timestamp
  type: GoalType;
  title: string;
  isCompleted: boolean;
}
const GOALS_KEY = 'goals_list';

// A map of all keys for easier management
const ALL_KEYS = {
    japaHistory: JAPA_HISTORY_KEY,
    recitationLogs: RECITATION_LOG_KEY,
    gratitudeNotes: GRATITUDE_NOTES_KEY,
    goals: GOALS_KEY,
};

// --- Existing Functions (Unchanged) ---

const saveJapaSession = async (session: JapaSession): Promise<void> => {
  try {
    const history = await getJapaHistory();
    const updatedHistory = [session, ...history];
    const jsonValue = JSON.stringify(updatedHistory);
    await AsyncStorage.setItem(JAPA_HISTORY_KEY, jsonValue);
  } catch (e) {
    console.error("Error saving japa session", e);
  }
};

const getJapaHistory = async (): Promise<JapaSession[]> => {
  try {
    const jsonValue = await AsyncStorage.getItem(JAPA_HISTORY_KEY);
    return jsonValue != null ? JSON.parse(jsonValue) : [];
  } catch (e) {
    console.error("Error fetching japa history", e);
    return [];
  }
};

const deleteJapaSession = async (dateId: string): Promise<void> => {
    try {
        const history = await getJapaHistory();
        const updatedHistory = history.filter(session => session.date !== dateId);
        const jsonValue = JSON.stringify(updatedHistory);
        await AsyncStorage.setItem(JAPA_HISTORY_KEY, jsonValue);
    } catch (e) {
        console.error("Error deleting japa session", e);
    }
};

const saveRecitationLog = async (log: RecitationLog): Promise<void> => {
    try {
        const history = await getRecitationLogs();
        const today = new Date().toISOString().split('T')[0];
        const existingLogIndex = history.findIndex(
            (item) => item.stotraId === log.stotraId && item.date.startsWith(today)
        );

        if (existingLogIndex > -1) {
            history[existingLogIndex].count += log.count;
        } else {
            history.unshift(log);
        }
        
        const jsonValue = JSON.stringify(history);
        await AsyncStorage.setItem(RECITATION_LOG_KEY, jsonValue);
    } catch (e) {
        console.error("Error saving recitation log", e);
    }
};

const getRecitationLogs = async (): Promise<RecitationLog[]> => {
    try {
        const jsonValue = await AsyncStorage.getItem(RECITATION_LOG_KEY);
        return jsonValue != null ? JSON.parse(jsonValue) : [];
    } catch (e) {
        console.error("Error fetching recitation logs", e);
        return [];
    }
};

const deleteRecitationLog = async (dateId: string): Promise<void> => {
    try {
        const history = await getRecitationLogs();
        const updatedHistory = history.filter(log => log.date !== dateId);
        const jsonValue = JSON.stringify(updatedHistory);
        await AsyncStorage.setItem(RECITATION_LOG_KEY, jsonValue);
    } catch (e) {
        console.error("Error deleting recitation log", e);
    }
};

const saveGratitudeNote = async (note: GratitudeNote): Promise<void> => {
    try {
        const notes = await getGratitudeNotes();
        notes.unshift(note);
        const jsonValue = JSON.stringify(notes);
        await AsyncStorage.setItem(GRATITUDE_NOTES_KEY, jsonValue);
    } catch (e) {
        console.error("Error saving gratitude note", e);
    }
};

const getGratitudeNotes = async (): Promise<GratitudeNote[]> => {
    try {
        const jsonValue = await AsyncStorage.getItem(GRATITUDE_NOTES_KEY);
        return jsonValue != null ? JSON.parse(jsonValue) : [];
    } catch (e) {
        console.error("Error fetching gratitude notes", e);
        return [];
    }
};

const deleteGratitudeNote = async (noteDate: string): Promise<void> => {
    try {
        const notes = await getGratitudeNotes();
        const updatedNotes = notes.filter(note => note.date !== noteDate);
        const jsonValue = JSON.stringify(updatedNotes);
        await AsyncStorage.setItem(GRATITUDE_NOTES_KEY, jsonValue);
    } catch (e) {
        console.error("Error deleting gratitude note", e);
    }
};

const getGoals = async (): Promise<Goal[]> => {
    try {
        const jsonValue = await AsyncStorage.getItem(GOALS_KEY);
        return jsonValue != null ? JSON.parse(jsonValue) : [];
    } catch (e) {
        console.error("Error fetching goals", e);
        return [];
    }
};

const saveGoal = async (newGoal: Goal): Promise<void> => {
    try {
        const goals = await getGoals();
        goals.unshift(newGoal);
        const jsonValue = JSON.stringify(goals);
        await AsyncStorage.setItem(GOALS_KEY, jsonValue);
    } catch (e) {
        console.error("Error saving goal", e);
    }
};

const updateGoalStatus = async (goalId: string, isCompleted: boolean): Promise<void> => {
    try {
        const goals = await getGoals();
        const goalIndex = goals.findIndex(g => g.id === goalId);
        if (goalIndex > -1) {
            goals[goalIndex].isCompleted = isCompleted;
            const jsonValue = JSON.stringify(goals);
            await AsyncStorage.setItem(GOALS_KEY, jsonValue);
        }
    } catch (e) {
        console.error("Error updating goal status", e);
    }
};

const deleteGoal = async (goalId: string): Promise<void> => {
    try {
        const goals = await getGoals();
        const updatedGoals = goals.filter(g => g.id !== goalId);
        const jsonValue = JSON.stringify(updatedGoals);
        await AsyncStorage.setItem(GOALS_KEY, jsonValue);
    } catch (e) {
        console.error("Error deleting goal", e);
    }
};

// --- NEW: Export/Import Functions ---
const exportAllData = async (): Promise<object> => {
    const dataToExport = {
        [ALL_KEYS.japaHistory]: await getJapaHistory(),
        [ALL_KEYS.recitationLogs]: await getRecitationLogs(),
        [ALL_KEYS.gratitudeNotes]: await getGratitudeNotes(),
        [ALL_KEYS.goals]: await getGoals(),
    };
    return dataToExport;
};

const importAllData = async (data: any): Promise<void> => {
    // Validate that the imported data has the keys we expect
    for (const key of Object.values(ALL_KEYS)) {
        if (data[key] && Array.isArray(data[key])) {
            const jsonValue = JSON.stringify(data[key]);
            await AsyncStorage.setItem(key, jsonValue);
        } else {
            console.warn(`Skipping import for key "${key}" due to missing or invalid data.`);
        }
    }
};

// --- Export all functions ---
export const StorageService = {
  saveJapaSession, getJapaHistory, deleteJapaSession,
  saveRecitationLog, getRecitationLogs, deleteRecitationLog, // Added deleteRecitationLog
  saveGratitudeNote, getGratitudeNotes, deleteGratitudeNote,
  getGoals, saveGoal, updateGoalStatus, deleteGoal,
  exportAllData, importAllData, // Add new functions here
};

===============================================
File: .expo\README.md
===============================================

> Why do I have a folder named ".expo" in my project?
The ".expo" folder is created when an Expo project is started using "expo start" command.
> What do the files contain?
- "devices.json": contains information about devices that have recently opened this project. This is used to populate the "Development sessions" list in your development builds.
- "settings.json": contains the server configuration that is used to serve the application manifest.
> Should I commit the ".expo" folder?
No, you should not share the ".expo" folder. It does not contain any information that is relevant for other developers working on the project, it is specific to your machine.
Upon project creation, the ".expo" folder is already added to your ".gitignore" file.


===============================================
File: .expo\devices.json
===============================================

{
  "devices": []
}


